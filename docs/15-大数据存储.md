# 大数据存储深度解析

## 目录
- [一、HBase](#一hbase)
- [二、ClickHouse](#二clickhouse)
- [三、数据分区策略](#三数据分区策略)
- [四、高频面试题](#四高频面试题)

## 一、HBase

### 1.1 架构

- **HMaster**：管理元数据
- **RegionServer**：数据存储
- **Region**：数据分区
- **Store**：列族存储
- **MemStore**：内存缓存
- **HFile**：磁盘文件

### 1.2 数据模型

```
RowKey | CF:Column | Timestamp | Value
user001 | info:name | 1234567890 | John
user001 | info:age  | 1234567890 | 30
```

### 1.3 Java API

```java
@Component
public class HBaseService {
    
    @Autowired
    private Connection connection;
    
    public void put(String tableName, String rowKey, 
                   String family, String qualifier, String value) throws IOException {
        Table table = connection.getTable(TableName.valueOf(tableName));
        Put put = new Put(Bytes.toBytes(rowKey));
        put.addColumn(
            Bytes.toBytes(family),
            Bytes.toBytes(qualifier),
            Bytes.toBytes(value)
        );
        table.put(put);
        table.close();
    }
    
    public String get(String tableName, String rowKey, 
                     String family, String qualifier) throws IOException {
        Table table = connection.getTable(TableName.valueOf(tableName));
        Get get = new Get(Bytes.toBytes(rowKey));
        Result result = table.get(get);
        byte[] value = result.getValue(
            Bytes.toBytes(family),
            Bytes.toBytes(qualifier)
        );
        table.close();
        return value != null ? Bytes.toString(value) : null;
    }
}
```

### 1.4 RowKey设计

**原则**：
1. 散列性：避免热点
2. 长度适中：10-100字节
3. 唯一性：防止覆盖

**示例**：
```java
// 反转时间戳
String rowKey = userId + "_" + (Long.MAX_VALUE - timestamp);

// Hash前缀
String rowKey = hash(userId) % 100 + "_" + userId + "_" + timestamp;
```

## 二、ClickHouse

### 2.1 特点

- 列式存储
- 向量化执行
- 数据压缩
- 支持SQL

### 2.2 建表

```sql
CREATE TABLE user_behavior (
    user_id UInt64,
    item_id UInt64,
    category_id UInt64,
    behavior String,
    timestamp DateTime
)
ENGINE = MergeTree()
PARTITION BY toYYYYMM(timestamp)
ORDER BY (user_id, timestamp)
SETTINGS index_granularity = 8192;
```

### 2.3 查询优化

```sql
-- 使用Prewhere
SELECT *
FROM user_behavior
PREWHERE user_id = 1001
WHERE behavior = 'click';

-- 使用物化视图
CREATE MATERIALIZED VIEW user_behavior_agg
ENGINE = AggregatingMergeTree()
PARTITION BY toYYYYMM(timestamp)
ORDER BY (user_id, timestamp)
AS SELECT
    user_id,
    timestamp,
    count() AS pv,
    uniq(item_id) AS uv
FROM user_behavior
GROUP BY user_id, timestamp;
```

## 三、数据分区策略

### 3.1 Range分区

```
partition1: [1, 1000]
partition2: [1001, 2000]
partition3: [2001, 3000]
```

### 3.2 Hash分区

```
partition = hash(key) % N
```

### 3.3 List分区

```
partition1: {BJ, SH, GZ}
partition2: {CD, WH, XA}
```

## 四、高频面试题

### Q1：HBase适合什么场景？

- 海量数据（TB/PB级）
- 稀疏数据
- 随机读写
- 实时查询

### Q2：ClickHouse为什么快？

1. 列式存储
2. 向量化执行
3. 数据压缩
4. 并行处理

### Q3：如何优化HBase读写性能？

**写优化**：
- 批量写入
- 预分区
- 关闭WAL（可选）

**读优化**：
- RowKey设计
- 布隆过滤器
- BlockCache

---

**关键字**：HBase、ClickHouse、列式存储、数据分区、RowKey设计

