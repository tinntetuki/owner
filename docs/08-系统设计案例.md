# 系统设计案例深度解析

## 目录
- [一、秒杀系统](#一秒杀系统)
- [二、短URL服务](#二短url服务)
- [三、IM系统](#三im系统)
- [四、推荐系统](#四推荐系统)
- [五、搜索系统](#五搜索系统)
- [六、分布式文件存储](#六分布式文件存储)

## 一、秒杀系统

### 1.1 核心挑战

- 高并发（10万+ QPS）
- 库存超卖
- 恶意刷单
- 系统雪崩

### 1.2 架构设计

```
┌──────────┐
│  CDN     │  静态资源
└────┬─────┘
     │
┌────▼─────┐
│  Nginx   │  限流、负载均衡
└────┬─────┘
     │
┌────▼─────┐
│ Gateway  │  鉴权、限流
└────┬─────┘
     │
┌────▼─────┐
│ Service  │
│  + Redis │  库存预扣
└────┬─────┘
     │
┌────▼─────┐
│   MQ     │  削峰填谷
└────┬─────┘
     │
┌────▼─────┐
│  Order   │  创建订单
└──────────┘
```

### 1.3 核心代码

**1. Redis库存预扣**：
```java
@Service
public class SeckillService {
    
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    @Autowired
    private RocketMQTemplate rocketMQTemplate;
    
    public SeckillResult seckill(Long userId, Long productId) {
        String stockKey = "seckill:stock:" + productId;
        String userKey = "seckill:user:" + productId + ":" + userId;
        
        // 1. 检查是否已购买
        if (Boolean.TRUE.equals(redisTemplate.hasKey(userKey))) {
            return SeckillResult.fail("already_bought");
        }
        
        // 2. Lua脚本扣减库存
        String script = 
            "local stock = redis.call('get', KEYS[1]) " +
            "if not stock or tonumber(stock) <= 0 then " +
            "    return 0 " +
            "end " +
            "redis.call('decr', KEYS[1]) " +
            "redis.call('setex', KEYS[2], 86400, '1') " +
            "return 1";
        
        Long result = redisTemplate.execute(
            new DefaultRedisScript<>(script, Long.class),
            Arrays.asList(stockKey, userKey)
        );
        
        if (result == null || result == 0) {
            return SeckillResult.fail("sold_out");
        }
        
        // 3. 发送MQ消息创建订单
        SeckillMessage message = new SeckillMessage(userId, productId);
        rocketMQTemplate.asyncSend("seckill-topic", message, new SendCallback() {
            @Override
            public void onSuccess(SendResult sendResult) {
                log.info("Message sent success");
            }
            
            @Override
            public void onException(Throwable e) {
                // 回滚库存
                redisTemplate.opsForValue().increment(stockKey);
                redisTemplate.delete(userKey);
            }
        });
        
        return SeckillResult.success();
    }
}
```

**2. 消息消费创建订单**：
```java
@Component
@RocketMQMessageListener(topic = "seckill-topic", consumerGroup = "order-group")
public class SeckillOrderListener implements RocketMQListener<SeckillMessage> {
    
    @Autowired
    private OrderService orderService;
    
    @Override
    @Transactional
    public void onMessage(SeckillMessage message) {
        try {
            // 创建订单
            Order order = orderService.createSeckillOrder(
                message.getUserId(),
                message.getProductId()
            );
            
            // 扣减数据库库存
            productService.deductStock(message.getProductId(), 1);
            
        } catch (Exception e) {
            log.error("Failed to create order", e);
            // 回滚Redis库存
            rollbackStock(message.getProductId(), message.getUserId());
        }
    }
}
```

**3. 防刷策略**：
```java
@Component
public class AntiCheatService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // 验证码
    public boolean verifyCaptcha(String token, String captcha) {
        String key = "captcha:" + token;
        String cached = (String) redisTemplate.opsForValue().get(key);
        if (cached != null && cached.equals(captcha)) {
            redisTemplate.delete(key);
            return true;
        }
        return false;
    }
    
    // 接口限流（用户维度）
    public boolean checkUserRate(Long userId) {
        String key = "rate:user:" + userId;
        Long count = redisTemplate.opsForValue().increment(key);
        if (count == 1) {
            redisTemplate.expire(key, 1, TimeUnit.SECONDS);
        }
        return count <= 10;  // 1秒最多10次
    }
    
    // 风控检测
    public boolean checkRisk(Long userId, String ip) {
        // 检查IP黑名单
        if (Boolean.TRUE.equals(redisTemplate.opsForSet().isMember("blacklist:ip", ip))) {
            return false;
        }
        
        // 检查同IP多账号
        String key = "ip:users:" + ip;
        redisTemplate.opsForSet().add(key, userId);
        Long count = redisTemplate.opsForSet().size(key);
        
        return count <= 5;  // 同IP最多5个账号
    }
}
```

## 二、短URL服务

### 2.1 设计要点

- 短码生成算法
- 高性能（10万+ QPS）
- 数据持久化
- 统计分析

### 2.2 短码生成

**方案1：Hash + Base62**：
```java
@Service
public class ShortUrlService {
    
    private static final String BASE62 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    
    public String shorten(String longUrl) {
        // 1. Hash
        long hash = MurmurHash.hash64(longUrl);
        
        // 2. Base62编码
        String shortCode = toBase62(Math.abs(hash));
        
        // 3. 保存映射
        redisTemplate.opsForValue().set("short:" + shortCode, longUrl);
        redisTemplate.opsForValue().set("long:" + longUrl, shortCode);
        
        return "http://short.url/" + shortCode;
    }
    
    private String toBase62(long num) {
        StringBuilder sb = new StringBuilder();
        while (num > 0) {
            sb.append(BASE62.charAt((int) (num % 62)));
            num /= 62;
        }
        return sb.reverse().toString();
    }
}
```

**方案2：发号器（推荐）**：
```java
@Service
public class IdGeneratorShortUrlService {
    
    @Autowired
    private IdGenerator idGenerator;  // Snowflake或数据库自增
    
    public String shorten(String longUrl) {
        // 1. 检查是否已存在
        String cached = (String) redisTemplate.opsForValue().get("long:" + longUrl);
        if (cached != null) {
            return cached;
        }
        
        // 2. 生成唯一ID
        long id = idGenerator.nextId();
        
        // 3. Base62编码
        String shortCode = toBase62(id);
        
        // 4. 保存映射
        saveMapping(shortCode, longUrl);
        
        return "http://short.url/" + shortCode;
    }
    
    private void saveMapping(String shortCode, String longUrl) {
        // Redis缓存
        redisTemplate.opsForValue().set("short:" + shortCode, longUrl, 7, TimeUnit.DAYS);
        
        // MySQL持久化
        UrlMapping mapping = new UrlMapping(shortCode, longUrl);
        urlMappingRepository.save(mapping);
    }
}
```

### 2.3 重定向服务

```java
@RestController
public class RedirectController {
    
    @Autowired
    private ShortUrlService shortUrlService;
    
    @GetMapping("/{shortCode}")
    public void redirect(@PathVariable String shortCode, HttpServletResponse response) 
            throws IOException {
        
        // 1. 查询长URL
        String longUrl = shortUrlService.getLongUrl(shortCode);
        if (longUrl == null) {
            response.sendError(404);
            return;
        }
        
        // 2. 统计（异步）
        CompletableFuture.runAsync(() -> {
            statisticsService.increment(shortCode);
        });
        
        // 3. 302重定向
        response.sendRedirect(longUrl);
    }
}
```

## 三、IM系统

### 3.1 架构设计

```
┌────────┐    WebSocket    ┌────────────┐
│ Client │<──────────────>│ Gateway    │
└────────┘                 └──────┬─────┘
                                  │
                           ┌──────▼─────┐
                           │ IM Service │
                           └──────┬─────┘
                                  │
                    ┌─────────────┼─────────────┐
                    │             │             │
            ┌───────▼──┐   ┌──────▼─────┐  ┌───▼────┐
            │  Redis   │   │    MySQL   │  │   MQ   │
            │ (在线状态)│   │  (消息存储)│  │ (消息) │
            └──────────┘   └────────────┘  └────────┘
```

### 3.2 核心功能

**1. 连接管理**：
```java
@Component
public class WebSocketHandler extends TextWebSocketHandler {
    
    private static final Map<Long, WebSocketSession> sessions = new ConcurrentHashMap<>();
    
    @Override
    public void afterConnectionEstablished(WebSocketSession session) {
        Long userId = getUserId(session);
        sessions.put(userId, session);
        
        // 设置在线状态
        redisTemplate.opsForValue().set("online:" + userId, "1", 30, TimeUnit.MINUTES);
    }
    
    @Override
    protected void handleTextMessage(WebSocketSession session, TextMessage message) {
        Long fromUserId = getUserId(session);
        Message msg = JSON.parseObject(message.getPayload(), Message.class);
        
        // 发送消息
        sendMessage(fromUserId, msg.getToUserId(), msg.getContent());
    }
    
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) {
        Long userId = getUserId(session);
        sessions.remove(userId);
        
        // 清除在线状态
        redisTemplate.delete("online:" + userId);
    }
}
```

**2. 消息发送**：
```java
@Service
public class MessageService {
    
    public void sendMessage(Long fromUserId, Long toUserId, String content) {
        // 1. 保存消息到数据库
        Message message = Message.builder()
            .fromUserId(fromUserId)
            .toUserId(toUserId)
            .content(content)
            .createTime(new Date())
            .build();
        messageRepository.save(message);
        
        // 2. 检查对方是否在线
        String onlineKey = "online:" + toUserId;
        if (Boolean.TRUE.equals(redisTemplate.hasKey(onlineKey))) {
            // 3. 在线则实时推送
            WebSocketSession session = sessions.get(toUserId);
            if (session != null && session.isOpen()) {
                session.sendMessage(new TextMessage(JSON.toJSONString(message)));
            }
        } else {
            // 4. 离线则推送到离线队列
            redisTemplate.opsForList().rightPush("offline:" + toUserId, message);
        }
    }
}
```

**3. 群聊**：
```java
@Service
public class GroupMessageService {
    
    public void sendGroupMessage(Long fromUserId, Long groupId, String content) {
        // 1. 获取群成员
        Set<Long> memberIds = groupService.getMembers(groupId);
        
        // 2. 保存消息
        GroupMessage message = new GroupMessage(fromUserId, groupId, content);
        messageRepository.save(message);
        
        // 3. 推送给在线成员
        for (Long memberId : memberIds) {
            if (memberId.equals(fromUserId)) continue;
            
            if (isOnline(memberId)) {
                pushMessage(memberId, message);
            } else {
                saveOfflineMessage(memberId, message);
            }
        }
    }
}
```

## 四、推荐系统

### 4.1 架构设计

```
┌────────────┐
│  User      │
│  Behavior  │  行为数据
└─────┬──────┘
      │
┌─────▼──────┐     ┌──────────┐
│  Feature   │────▶│  Model   │  训练
│  Engineer  │     │  Training│
└────────────┘     └─────┬────┘
                         │
                   ┌─────▼────┐
                   │  Model   │  模型
                   └─────┬────┘
                         │
┌────────────┐     ┌─────▼────┐
│  Real-time │────▶│ Serving  │  预测
│  Features  │     └─────┬────┘
└────────────┘           │
                   ┌─────▼────┐
                   │  Re-rank │  重排序
                   └──────────┘
```

### 4.2 召回策略

```java
@Service
public class RecallService {
    
    // 多路召回
    public List<Long> recall(Long userId, int count) {
        // 1. 协同过滤召回
        List<Long> cfItems = collaborativeFiltering(userId, count / 3);
        
        // 2. 内容召回
        List<Long> contentItems = contentBasedRecall(userId, count / 3);
        
        // 3. 热门召回
        List<Long> hotItems = hotRecall(count / 3);
        
        // 4. 合并去重
        Set<Long> result = new LinkedHashSet<>();
        result.addAll(cfItems);
        result.addAll(contentItems);
        result.addAll(hotItems);
        
        return new ArrayList<>(result);
    }
    
    // 协同过滤
    private List<Long> collaborativeFiltering(Long userId, int count) {
        // UserCF或ItemCF
        return userCfService.recommend(userId, count);
    }
    
    // 内容召回
    private List<Long> contentBasedRecall(Long userId, int count) {
        // 基于用户画像
        UserProfile profile = userProfileService.getProfile(userId);
        return contentService.search(profile.getTags(), count);
    }
    
    // 热门召回
    private List<Long> hotRecall(int count) {
        return redisTemplate.opsForZSet()
            .reverseRange("hot:items", 0, count - 1)
            .stream()
            .map(Long::valueOf)
            .collect(Collectors.toList());
    }
}
```

## 五、搜索系统

### 5.1 架构设计

```
┌────────┐     ┌──────────┐
│ MySQL  │────▶│ Binlog   │
└────────┘     │ Listener │
                └─────┬────┘
                      │
                ┌─────▼────┐
                │    ES    │
                └─────┬────┘
                      │
┌────────┐     ┌─────▼────┐
│ Client │────▶│  Search  │
└────────┘     │  Service │
                └──────────┘
```

### 5.2 搜索实现

```java
@Service
public class SearchService {
    
    @Autowired
    private ElasticsearchRestTemplate esTemplate;
    
    public SearchResult search(String keyword, int page, int size) {
        // 1. 构建查询
        NativeSearchQuery query = new NativeSearchQueryBuilder()
            .withQuery(QueryBuilders.multiMatchQuery(keyword, "title", "description")
                .type(MultiMatchQueryBuilder.Type.BEST_FIELDS)
                .fuzziness(Fuzziness.AUTO))
            .withPageable(PageRequest.of(page, size))
            .withHighlightFields(
                new HighlightBuilder.Field("title"),
                new HighlightBuilder.Field("description"))
            .build();
        
        // 2. 执行搜索
        SearchHits<Product> hits = esTemplate.search(query, Product.class);
        
        // 3. 处理结果
        List<Product> products = hits.stream()
            .map(SearchHit::getContent)
            .collect(Collectors.toList());
        
        return new SearchResult(products, hits.getTotalHits());
    }
}
```

## 六、分布式文件存储

### 6.1 架构设计

```
┌────────┐     ┌──────────┐
│ Client │────▶│  Upload  │
└────────┘     │  Service │
                └─────┬────┘
                      │
                ┌─────▼────┐
                │   OSS    │  对象存储
                └─────┬────┘
                      │
                ┌─────▼────┐
                │   CDN    │  加速
                └──────────┘
```

### 6.2 文件上传

```java
@Service
public class FileUploadService {
    
    @Autowired
    private OSS ossClient;
    
    public String upload(MultipartFile file) throws IOException {
        // 1. 生成文件名
        String fileName = generateFileName(file.getOriginalFilename());
        
        // 2. 上传到OSS
        ossClient.putObject("bucket-name", fileName, file.getInputStream());
        
        // 3. 生成访问URL
        String url = ossClient.generatePresignedUrl("bucket-name", fileName, 
            new Date(System.currentTimeMillis() + 3600 * 1000)).toString();
        
        // 4. 保存元数据
        FileMetadata metadata = new FileMetadata(fileName, file.getSize(), url);
        metadataRepository.save(metadata);
        
        return url;
    }
    
    private String generateFileName(String originalName) {
        String ext = originalName.substring(originalName.lastIndexOf("."));
        return UUID.randomUUID().toString().replace("-", "") + ext;
    }
}
```

---

**关键字**：秒杀、短URL、IM、推荐系统、搜索系统、文件存储

