# 性能优化实战

## 目录
- [一、代码优化](#一代码优化)
- [二、JVM优化](#二jvm优化)
- [三、数据库优化](#三数据库优化)
- [四、架构优化](#四架构优化)

## 一、代码优化

### 1.1 字符串拼接

```java
// 差
String result = "";
for (int i = 0; i < 10000; i++) {
    result += i;  // 创建大量String对象
}

// 好
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 10000; i++) {
    sb.append(i);
}
String result = sb.toString();
```

### 1.2 集合选择

```java
// ArrayList vs LinkedList
List<String> list1 = new ArrayList<>();  // 随机访问多
List<String> list2 = new LinkedList<>(); // 频繁插入删除

// HashMap vs ConcurrentHashMap
Map<String, String> map1 = new HashMap<>();  // 单线程
Map<String, String> map2 = new ConcurrentHashMap<>();  // 多线程
```

### 1.3 对象复用

```java
// 线程池
ExecutorService executor = Executors.newFixedThreadPool(10);

// 连接池
DruidDataSource dataSource = new DruidDataSource();
dataSource.setMaxActive(100);

// 对象池
GenericObjectPool<Connection> pool = new GenericObjectPool<>(factory);
```

## 二、JVM优化

### 2.1 参数调优

```bash
# 堆内存
-Xms4g -Xmx4g  # 初始和最大堆相同

# 新生代
-Xmn2g  # 新生代2G
-XX:SurvivorRatio=8  # Eden:Survivor = 8:1

# GC选择
-XX:+UseG1GC  # 使用G1
-XX:MaxGCPauseMillis=200  # 期望停顿200ms

# GC日志
-Xlog:gc*:file=gc.log:time,uptime,level,tags
```

### 2.2 内存泄漏排查

```bash
# 1. dump堆快照
jmap -dump:format=b,file=heap.hprof <pid>

# 2. 使用MAT分析
# 查找Leak Suspects

# 3. 查看占用内存最大的对象
jmap -histo:live <pid> | head -20
```

## 三、数据库优化

### 3.1 索引优化

```sql
-- 创建索引
CREATE INDEX idx_name ON user(name);

-- 联合索引
CREATE INDEX idx_name_age ON user(name, age);

-- 覆盖索引
CREATE INDEX idx_name_age_city ON user(name, age, city);
SELECT name, age, city FROM user WHERE name = 'John';  -- 无需回表
```

### 3.2 查询优化

```sql
-- 避免SELECT *
SELECT id, name, age FROM user WHERE id = 1;

-- 使用LIMIT
SELECT * FROM user LIMIT 1000;

-- 优化JOIN
SELECT u.name, o.order_no
FROM user u
JOIN order o ON u.id = o.user_id  -- 确保user_id有索引
WHERE u.city = 'Beijing';

-- 批量操作
INSERT INTO user (name, age) VALUES 
    ('John', 30),
    ('Jane', 25),
    ('Bob', 35);
```

### 3.3 分库分表

```yaml
# ShardingSphere配置
rules:
  - !SHARDING
    tables:
      order:
        actualDataNodes: ds_${0..3}.order_${0..3}
        tableStrategy:
          standard:
            shardingColumn: order_id
            shardingAlgorithmName: order_inline
        databaseStrategy:
          standard:
            shardingColumn: user_id
            shardingAlgorithmName: database_inline
```

## 四、架构优化

### 4.1 缓存

```java
// 多级缓存
@Service
public class ProductService {
    
    @Autowired
    private Cache<Long, Product> localCache;  // L1: 本地缓存
    
    @Autowired
    private RedisTemplate<String, Product> redisTemplate;  // L2: Redis
    
    public Product getProduct(Long id) {
        // L1缓存
        Product product = localCache.getIfPresent(id);
        if (product != null) {
            return product;
        }
        
        // L2缓存
        product = redisTemplate.opsForValue().get("product:" + id);
        if (product != null) {
            localCache.put(id, product);
            return product;
        }
        
        // 数据库
        product = productMapper.selectById(id);
        if (product != null) {
            redisTemplate.opsForValue().set("product:" + id, product, 1, TimeUnit.HOURS);
            localCache.put(id, product);
        }
        
        return product;
    }
}
```

### 4.2 异步处理

```java
@Service
public class OrderService {
    
    @Autowired
    private RocketMQTemplate rocketMQTemplate;
    
    @Transactional
    public void createOrder(Order order) {
        // 1. 同步：创建订单
        orderMapper.insert(order);
        
        // 2. 异步：发送通知
        rocketMQTemplate.asyncSend("order-topic", order, new SendCallback() {
            @Override
            public void onSuccess(SendResult sendResult) {
                log.info("Message sent");
            }
            
            @Override
            public void onException(Throwable e) {
                log.error("Failed to send message", e);
            }
        });
    }
}
```

### 4.3 批处理

```java
@Service
public class BatchService {
    
    public void batchInsert(List<User> users) {
        // 分批处理
        int batchSize = 1000;
        for (int i = 0; i < users.size(); i += batchSize) {
            List<User> batch = users.subList(
                i, 
                Math.min(i + batchSize, users.size())
            );
            userMapper.batchInsert(batch);
        }
    }
}
```

---

**关键字**：性能优化、JVM调优、数据库优化、缓存、异步、批处理

