# 安全架构设计深度解析 - 架构师级技术指南

## 目录
- [一、安全架构概述](#一安全架构概述)
- [二、认证授权体系](#二认证授权体系)
- [三、API安全设计](#三api安全设计)
- [四、数据安全保护](#四数据安全保护)
- [五、网络安全防护](#五网络安全防护)
- [六、应用安全防护](#六应用安全防护)
- [七、安全监控与审计](#七安全监控与审计)
- [八、安全合规管理](#八安全合规管理)
- [九、安全架构实践](#九安全架构实践)
- [十、高频面试题](#十高频面试题)

## 一、安全架构概述

### 1.1 安全架构的定义

**安全架构**是指在系统架构设计中，通过技术手段和管理措施，确保系统在机密性、完整性、可用性等方面的安全要求得到满足的架构设计方法。

**安全架构的核心要素**：
- **机密性(Confidentiality)**：确保信息不被未授权访问
- **完整性(Integrity)**：确保信息不被未授权修改
- **可用性(Availability)**：确保授权用户能够正常访问系统
- **可审计性(Accountability)**：确保所有操作可追溯和审计

### 1.2 安全架构原则

**安全架构设计原则**：
```java
// 安全架构设计原则实现
@Component
public class SecurityArchitecturePrinciples {
    
    // 1. 最小权限原则
    public void implementLeastPrivilege() {
        // 用户只获得完成工作所需的最小权限
        UserRole role = new UserRole();
        role.setPermissions(getMinimalRequiredPermissions());
        role.setAccessLevel(AccessLevel.MINIMAL);
        
        // 定期审查和撤销不必要的权限
        schedulePermissionReview();
    }
    
    // 2. 深度防御原则
    public void implementDefenseInDepth() {
        // 多层安全防护
        SecurityLayer networkLayer = createNetworkSecurityLayer();
        SecurityLayer applicationLayer = createApplicationSecurityLayer();
        SecurityLayer dataLayer = createDataSecurityLayer();
        
        // 每层都有独立的安全措施
        networkLayer.setFirewall(true);
        applicationLayer.setAuthentication(true);
        dataLayer.setEncryption(true);
    }
    
    // 3. 零信任原则
    public void implementZeroTrust() {
        // 不信任任何网络、设备或用户
        ZeroTrustPolicy policy = new ZeroTrustPolicy();
        policy.setTrustNothing(true);
        policy.setVerifyEverything(true);
        policy.setContinuousMonitoring(true);
        
        // 所有访问都需要验证
        enforceContinuousVerification();
    }
    
    // 4. 安全默认原则
    public void implementSecureByDefault() {
        // 默认配置应该是安全的
        SecurityConfiguration config = new SecurityConfiguration();
        config.setDefaultSecure(true);
        config.setEncryptionEnabled(true);
        config.setAuthenticationRequired(true);
        config.setLoggingEnabled(true);
    }
    
    // 5. 故障安全原则
    public void implementFailSecure() {
        // 系统故障时应该拒绝访问
        SecurityPolicy policy = new SecurityPolicy();
        policy.setFailSecure(true);
        policy.setDefaultDeny(true);
        policy.setExceptionHandling(SecurityExceptionHandling.DENY);
    }
}
```

### 1.3 安全威胁模型

**安全威胁分析**：
```java
// 安全威胁模型
@Component
public class SecurityThreatModel {
    
    // STRIDE威胁模型
    public ThreatAnalysis analyzeThreats(ApplicationProfile profile) {
        ThreatAnalysis analysis = new ThreatAnalysis();
        
        // 分析Spoofing威胁
        List<Threat> spoofingThreats = analyzeSpoofingThreats(profile);
        analysis.setSpoofingThreats(spoofingThreats);
        
        // 分析Tampering威胁
        List<Threat> tamperingThreats = analyzeTamperingThreats(profile);
        analysis.setTamperingThreats(tamperingThreats);
        
        // 分析Repudiation威胁
        List<Threat> repudiationThreats = analyzeRepudiationThreats(profile);
        analysis.setRepudiationThreats(repudiationThreats);
        
        // 分析Information Disclosure威胁
        List<Threat> disclosureThreats = analyzeDisclosureThreats(profile);
        analysis.setDisclosureThreats(disclosureThreats);
        
        // 分析Denial of Service威胁
        List<Threat> dosThreats = analyzeDoSThreats(profile);
        analysis.setDoSThreats(dosThreats);
        
        // 分析Elevation of Privilege威胁
        List<Threat> privilegeThreats = analyzePrivilegeThreats(profile);
        analysis.setPrivilegeThreats(privilegeThreats);
        
        return analysis;
    }
    
    // 威胁风险评估
    public RiskAssessment assessThreats(List<Threat> threats) {
        RiskAssessment assessment = new RiskAssessment();
        
        for (Threat threat : threats) {
            // 计算威胁概率
            double probability = calculateThreatProbability(threat);
            
            // 计算威胁影响
            double impact = calculateThreatImpact(threat);
            
            // 计算风险等级
            RiskLevel riskLevel = calculateRiskLevel(probability, impact);
            
            // 生成缓解措施
            List<MitigationMeasure> mitigations = generateMitigationMeasures(threat, riskLevel);
            
            ThreatRisk threatRisk = new ThreatRisk(threat, probability, impact, riskLevel, mitigations);
            assessment.addThreatRisk(threatRisk);
        }
        
        return assessment;
    }
    
    private double calculateThreatProbability(Threat threat) {
        // 基于威胁类型、攻击难度、防护措施等因素计算概率
        double baseProbability = threat.getBaseProbability();
        double attackDifficulty = threat.getAttackDifficulty();
        double protectionLevel = threat.getProtectionLevel();
        
        return baseProbability * (1 - attackDifficulty) * (1 - protectionLevel);
    }
    
    private double calculateThreatImpact(Threat threat) {
        // 基于业务影响、数据价值、恢复成本等因素计算影响
        double businessImpact = threat.getBusinessImpact();
        double dataValue = threat.getDataValue();
        double recoveryCost = threat.getRecoveryCost();
        
        return (businessImpact + dataValue + recoveryCost) / 3.0;
    }
    
    private RiskLevel calculateRiskLevel(double probability, double impact) {
        double riskScore = probability * impact;
        
        if (riskScore >= 0.8) {
            return RiskLevel.HIGH;
        } else if (riskScore >= 0.5) {
            return RiskLevel.MEDIUM;
        } else {
            return RiskLevel.LOW;
        }
    }
}
```

## 二、认证授权体系

### 2.1 OAuth2.0实现

**OAuth2.0认证服务**：
```java
// OAuth2.0认证服务
@Service
public class OAuth2AuthenticationService {
    
    @Autowired
    private ClientService clientService;
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private TokenService tokenService;
    
    // 授权码模式
    public AuthorizationCodeResponse authorizeCode(AuthorizationRequest request) {
        // 验证客户端
        Client client = clientService.validateClient(request.getClientId());
        if (client == null) {
            throw new InvalidClientException("Invalid client");
        }
        
        // 验证重定向URI
        if (!client.getRedirectUris().contains(request.getRedirectUri())) {
            throw new InvalidRedirectUriException("Invalid redirect URI");
        }
        
        // 验证用户身份
        User user = userService.authenticate(request.getUsername(), request.getPassword());
        if (user == null) {
            throw new AuthenticationException("Invalid credentials");
        }
        
        // 生成授权码
        String authorizationCode = generateAuthorizationCode(client, user, request.getScope());
        
        // 存储授权码
        tokenService.storeAuthorizationCode(authorizationCode, client, user, request.getScope());
        
        return new AuthorizationCodeResponse(authorizationCode, request.getState());
    }
    
    // 获取访问令牌
    public AccessTokenResponse getAccessToken(TokenRequest request) {
        // 验证授权码
        AuthorizationCodeInfo codeInfo = tokenService.validateAuthorizationCode(request.getCode());
        if (codeInfo == null) {
            throw new InvalidAuthorizationCodeException("Invalid authorization code");
        }
        
        // 验证客户端
        if (!codeInfo.getClientId().equals(request.getClientId())) {
            throw new InvalidClientException("Client mismatch");
        }
        
        // 生成访问令牌
        String accessToken = generateAccessToken(codeInfo.getUser(), codeInfo.getScope());
        
        // 生成刷新令牌
        String refreshToken = generateRefreshToken(codeInfo.getUser(), codeInfo.getScope());
        
        // 存储令牌
        tokenService.storeAccessToken(accessToken, codeInfo.getUser(), codeInfo.getScope());
        tokenService.storeRefreshToken(refreshToken, codeInfo.getUser(), codeInfo.getScope());
        
        return new AccessTokenResponse(accessToken, "Bearer", 3600, refreshToken, codeInfo.getScope());
    }
    
    // 刷新访问令牌
    public AccessTokenResponse refreshAccessToken(RefreshTokenRequest request) {
        // 验证刷新令牌
        RefreshTokenInfo tokenInfo = tokenService.validateRefreshToken(request.getRefreshToken());
        if (tokenInfo == null) {
            throw new InvalidRefreshTokenException("Invalid refresh token");
        }
        
        // 生成新的访问令牌
        String newAccessToken = generateAccessToken(tokenInfo.getUser(), tokenInfo.getScope());
        
        // 存储新令牌
        tokenService.storeAccessToken(newAccessToken, tokenInfo.getUser(), tokenInfo.getScope());
        
        return new AccessTokenResponse(newAccessToken, "Bearer", 3600, request.getRefreshToken(), tokenInfo.getScope());
    }
    
    private String generateAuthorizationCode(Client client, User user, String scope) {
        // 生成随机授权码
        return UUID.randomUUID().toString().replace("-", "");
    }
    
    private String generateAccessToken(User user, String scope) {
        // 生成JWT访问令牌
        return Jwts.builder()
            .setSubject(user.getId())
            .setIssuedAt(new Date())
            .setExpiration(new Date(System.currentTimeMillis() + 3600000))
            .claim("scope", scope)
            .claim("user_id", user.getId())
            .signWith(SignatureAlgorithm.HS256, getSecretKey())
            .compact();
    }
    
    private String generateRefreshToken(User user, String scope) {
        // 生成刷新令牌
        return UUID.randomUUID().toString().replace("-", "");
    }
}
```

### 2.2 JWT实现

**JWT令牌服务**：
```java
// JWT令牌服务
@Service
public class JwtTokenService {
    
    private final String secretKey = "mySecretKey";
    private final long accessTokenValidity = 3600000; // 1小时
    private final long refreshTokenValidity = 86400000; // 24小时
    
    // 生成访问令牌
    public String generateAccessToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("authorities", userDetails.getAuthorities());
        claims.put("user_id", userDetails.getUsername());
        
        return createToken(claims, userDetails.getUsername(), accessTokenValidity);
    }
    
    // 生成刷新令牌
    public String generateRefreshToken(UserDetails userDetails) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("type", "refresh");
        claims.put("user_id", userDetails.getUsername());
        
        return createToken(claims, userDetails.getUsername(), refreshTokenValidity);
    }
    
    // 创建令牌
    private String createToken(Map<String, Object> claims, String subject, long validity) {
        return Jwts.builder()
            .setClaims(claims)
            .setSubject(subject)
            .setIssuedAt(new Date(System.currentTimeMillis()))
            .setExpiration(new Date(System.currentTimeMillis() + validity))
            .signWith(SignatureAlgorithm.HS256, secretKey)
            .compact();
    }
    
    // 验证令牌
    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }
    
    // 从令牌中获取用户名
    public String getUsernameFromToken(String token) {
        return getClaimFromToken(token, Claims::getSubject);
    }
    
    // 从令牌中获取过期时间
    public Date getExpirationDateFromToken(String token) {
        return getClaimFromToken(token, Claims::getExpiration);
    }
    
    // 检查令牌是否过期
    public Boolean isTokenExpired(String token) {
        final Date expiration = getExpirationDateFromToken(token);
        return expiration.before(new Date());
    }
    
    // 从令牌中获取声明
    public <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = getAllClaimsFromToken(token);
        return claimsResolver.apply(claims);
    }
    
    // 从令牌中获取所有声明
    private Claims getAllClaimsFromToken(String token) {
        return Jwts.parser()
            .setSigningKey(secretKey)
            .parseClaimsJws(token)
            .getBody();
    }
    
    // 刷新令牌
    public String refreshToken(String refreshToken) {
        if (validateToken(refreshToken)) {
            String username = getUsernameFromToken(refreshToken);
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);
            return generateAccessToken(userDetails);
        }
        throw new InvalidTokenException("Invalid refresh token");
    }
}
```

### 2.3 RBAC权限控制

**RBAC权限控制实现**：
```java
// RBAC权限控制
@Service
public class RbacPermissionService {
    
    @Autowired
    private RoleRepository roleRepository;
    
    @Autowired
    private PermissionRepository permissionRepository;
    
    @Autowired
    private UserRoleRepository userRoleRepository;
    
    // 检查用户权限
    public boolean hasPermission(String userId, String resource, String action) {
        // 获取用户角色
        List<Role> userRoles = getUserRoles(userId);
        
        // 检查角色权限
        for (Role role : userRoles) {
            if (hasRolePermission(role, resource, action)) {
                return true;
            }
        }
        
        return false;
    }
    
    // 获取用户角色
    private List<Role> getUserRoles(String userId) {
        List<UserRole> userRoles = userRoleRepository.findByUserId(userId);
        return userRoles.stream()
            .map(UserRole::getRole)
            .collect(Collectors.toList());
    }
    
    // 检查角色权限
    private boolean hasRolePermission(Role role, String resource, String action) {
        List<Permission> rolePermissions = role.getPermissions();
        
        for (Permission permission : rolePermissions) {
            if (permission.getResource().equals(resource) && 
                permission.getAction().equals(action)) {
                return true;
            }
        }
        
        return false;
    }
    
    // 创建角色
    public Role createRole(String roleName, String description, List<String> permissionIds) {
        Role role = new Role();
        role.setName(roleName);
        role.setDescription(description);
        role.setCreatedAt(LocalDateTime.now());
        
        // 设置权限
        List<Permission> permissions = permissionRepository.findAllById(permissionIds);
        role.setPermissions(permissions);
        
        return roleRepository.save(role);
    }
    
    // 分配用户角色
    public void assignUserRole(String userId, String roleId) {
        UserRole userRole = new UserRole();
        userRole.setUserId(userId);
        userRole.setRoleId(roleId);
        userRole.setAssignedAt(LocalDateTime.now());
        
        userRoleRepository.save(userRole);
    }
    
    // 撤销用户角色
    public void revokeUserRole(String userId, String roleId) {
        userRoleRepository.deleteByUserIdAndRoleId(userId, roleId);
    }
    
    // 获取用户权限列表
    public List<Permission> getUserPermissions(String userId) {
        List<Role> userRoles = getUserRoles(userId);
        return userRoles.stream()
            .flatMap(role -> role.getPermissions().stream())
            .distinct()
            .collect(Collectors.toList());
    }
    
    // 权限继承
    public void inheritPermissions(String childRoleId, String parentRoleId) {
        Role childRole = roleRepository.findById(childRoleId).orElseThrow();
        Role parentRole = roleRepository.findById(parentRoleId).orElseThrow();
        
        // 继承父角色权限
        List<Permission> inheritedPermissions = new ArrayList<>(parentRole.getPermissions());
        inheritedPermissions.addAll(childRole.getPermissions());
        
        childRole.setPermissions(inheritedPermissions);
        roleRepository.save(childRole);
    }
}
```

## 三、API安全设计

### 3.1 API安全防护

**API安全防护实现**：
```java
// API安全防护
@Component
public class ApiSecurityFilter implements Filter {
    
    @Autowired
    private RateLimitService rateLimitService;
    
    @Autowired
    private AuthenticationService authenticationService;
    
    @Autowired
    private AuthorizationService authorizationService;
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 
            throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        
        try {
            // 1. 请求频率限制
            if (!rateLimitService.isAllowed(httpRequest)) {
                httpResponse.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
                return;
            }
            
            // 2. 身份认证
            if (!authenticationService.isAuthenticated(httpRequest)) {
                httpResponse.setStatus(HttpStatus.UNAUTHORIZED.value());
                return;
            }
            
            // 3. 权限授权
            if (!authorizationService.isAuthorized(httpRequest)) {
                httpResponse.setStatus(HttpStatus.FORBIDDEN.value());
                return;
            }
            
            // 4. 请求签名验证
            if (!validateSignature(httpRequest)) {
                httpResponse.setStatus(HttpStatus.UNAUTHORIZED.value());
                return;
            }
            
            // 5. 请求参数验证
            if (!validateParameters(httpRequest)) {
                httpResponse.setStatus(HttpStatus.BAD_REQUEST.value());
                return;
            }
            
            chain.doFilter(request, response);
            
        } catch (Exception e) {
            log.error("API security filter error", e);
            httpResponse.setStatus(HttpStatus.INTERNAL_SERVER_ERROR.value());
        }
    }
    
    // 验证请求签名
    private boolean validateSignature(HttpServletRequest request) {
        String signature = request.getHeader("X-Signature");
        String timestamp = request.getHeader("X-Timestamp");
        String nonce = request.getHeader("X-Nonce");
        
        if (signature == null || timestamp == null || nonce == null) {
            return false;
        }
        
        // 验证时间戳（防重放攻击）
        long currentTime = System.currentTimeMillis();
        long requestTime = Long.parseLong(timestamp);
        if (Math.abs(currentTime - requestTime) > 300000) { // 5分钟
            return false;
        }
        
        // 验证签名
        String expectedSignature = calculateSignature(request, timestamp, nonce);
        return signature.equals(expectedSignature);
    }
    
    // 计算请求签名
    private String calculateSignature(HttpServletRequest request, String timestamp, String nonce) {
        String method = request.getMethod();
        String uri = request.getRequestURI();
        String queryString = request.getQueryString();
        String body = getRequestBody(request);
        
        String stringToSign = method + "\n" + uri + "\n" + queryString + "\n" + body + "\n" + timestamp + "\n" + nonce;
        
        return HmacUtils.hmacSha256Hex(secretKey, stringToSign);
    }
    
    // 验证请求参数
    private boolean validateParameters(HttpServletRequest request) {
        // 检查SQL注入
        if (containsSqlInjection(request)) {
            return false;
        }
        
        // 检查XSS攻击
        if (containsXss(request)) {
            return false;
        }
        
        // 检查路径遍历
        if (containsPathTraversal(request)) {
            return false;
        }
        
        return true;
    }
    
    // 检查SQL注入
    private boolean containsSqlInjection(HttpServletRequest request) {
        String[] sqlKeywords = {"'", "\"", ";", "--", "/*", "*/", "xp_", "sp_", "exec", "execute", "union", "select", "insert", "update", "delete", "drop", "create", "alter"};
        
        for (String paramName : request.getParameterMap().keySet()) {
            String[] paramValues = request.getParameterValues(paramName);
            for (String value : paramValues) {
                for (String keyword : sqlKeywords) {
                    if (value.toLowerCase().contains(keyword.toLowerCase())) {
                        return true;
                    }
                }
            }
        }
        
        return false;
    }
    
    // 检查XSS攻击
    private boolean containsXss(HttpServletRequest request) {
        String[] xssPatterns = {"<script", "</script", "javascript:", "onload=", "onerror=", "onclick="};
        
        for (String paramName : request.getParameterMap().keySet()) {
            String[] paramValues = request.getParameterValues(paramName);
            for (String value : paramValues) {
                for (String pattern : xssPatterns) {
                    if (value.toLowerCase().contains(pattern.toLowerCase())) {
                        return true;
                    }
                }
            }
        }
        
        return false;
    }
    
    // 检查路径遍历
    private boolean containsPathTraversal(HttpServletRequest request) {
        String[] traversalPatterns = {"../", "..\\", "%2e%2e%2f", "%2e%2e%5c"};
        
        for (String paramName : request.getParameterMap().keySet()) {
            String[] paramValues = request.getParameterValues(paramName);
            for (String value : paramValues) {
                for (String pattern : traversalPatterns) {
                    if (value.contains(pattern)) {
                        return true;
                    }
                }
            }
        }
        
        return false;
    }
}
```

### 3.2 API网关安全

**API网关安全实现**：
```java
// API网关安全
@Component
public class ApiGatewaySecurity {
    
    @Autowired
    private RouteService routeService;
    
    @Autowired
    private SecurityPolicyService securityPolicyService;
    
    // 路由安全验证
    public boolean validateRouteSecurity(HttpServletRequest request) {
        String requestPath = request.getRequestURI();
        String method = request.getMethod();
        
        // 获取路由配置
        Route route = routeService.getRoute(requestPath);
        if (route == null) {
            return false;
        }
        
        // 获取安全策略
        SecurityPolicy policy = securityPolicyService.getSecurityPolicy(route.getServiceId());
        if (policy == null) {
            return false;
        }
        
        // 验证认证要求
        if (policy.isAuthenticationRequired() && !isAuthenticated(request)) {
            return false;
        }
        
        // 验证授权要求
        if (policy.isAuthorizationRequired() && !isAuthorized(request, route)) {
            return false;
        }
        
        // 验证IP白名单
        if (policy.hasIpWhitelist() && !isIpWhitelisted(request, policy)) {
            return false;
        }
        
        // 验证请求频率
        if (policy.hasRateLimit() && !isRateLimitAllowed(request, policy)) {
            return false;
        }
        
        return true;
    }
    
    // 请求转换
    public HttpServletRequest transformRequest(HttpServletRequest request) {
        // 添加安全头
        HttpServletRequestWrapper wrappedRequest = new HttpServletRequestWrapper(request) {
            @Override
            public String getHeader(String name) {
                String header = super.getHeader(name);
                if (name.equals("X-Forwarded-For")) {
                    return getClientIpAddress();
                }
                if (name.equals("X-Real-IP")) {
                    return getClientIpAddress();
                }
                return header;
            }
        };
        
        return wrappedRequest;
    }
    
    // 响应转换
    public HttpServletResponse transformResponse(HttpServletResponse response) {
        // 添加安全头
        response.setHeader("X-Content-Type-Options", "nosniff");
        response.setHeader("X-Frame-Options", "DENY");
        response.setHeader("X-XSS-Protection", "1; mode=block");
        response.setHeader("Strict-Transport-Security", "max-age=31536000; includeSubDomains");
        response.setHeader("Content-Security-Policy", "default-src 'self'");
        
        return response;
    }
    
    // 获取客户端IP地址
    private String getClientIpAddress() {
        // 实现获取真实客户端IP的逻辑
        return "127.0.0.1";
    }
    
    // 检查IP白名单
    private boolean isIpWhitelisted(HttpServletRequest request, SecurityPolicy policy) {
        String clientIp = getClientIpAddress();
        return policy.getIpWhitelist().contains(clientIp);
    }
    
    // 检查请求频率限制
    private boolean isRateLimitAllowed(HttpServletRequest request, SecurityPolicy policy) {
        String clientIp = getClientIpAddress();
        return rateLimitService.isAllowed(clientIp, policy.getRateLimit());
    }
}
```

## 四、数据安全保护

### 4.1 数据加密

**数据加密服务**：
```java
// 数据加密服务
@Service
public class DataEncryptionService {
    
    private final String algorithm = "AES";
    private final String transformation = "AES/CBC/PKCS5Padding";
    private final String keyAlgorithm = "AES";
    private final int keyLength = 256;
    
    // 对称加密
    public String encrypt(String plaintext, String key) {
        try {
            SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), keyAlgorithm);
            Cipher cipher = Cipher.getInstance(transformation);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            
            byte[] encryptedBytes = cipher.doFinal(plaintext.getBytes());
            return Base64.getEncoder().encodeToString(encryptedBytes);
        } catch (Exception e) {
            throw new EncryptionException("Failed to encrypt data", e);
        }
    }
    
    // 对称解密
    public String decrypt(String ciphertext, String key) {
        try {
            SecretKeySpec secretKey = new SecretKeySpec(key.getBytes(), keyAlgorithm);
            Cipher cipher = Cipher.getInstance(transformation);
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            
            byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(ciphertext));
            return new String(decryptedBytes);
        } catch (Exception e) {
            throw new DecryptionException("Failed to decrypt data", e);
        }
    }
    
    // 非对称加密
    public String encryptAsymmetric(String plaintext, PublicKey publicKey) {
        try {
            Cipher cipher = Cipher.getInstance("RSA");
            cipher.init(Cipher.ENCRYPT_MODE, publicKey);
            
            byte[] encryptedBytes = cipher.doFinal(plaintext.getBytes());
            return Base64.getEncoder().encodeToString(encryptedBytes);
        } catch (Exception e) {
            throw new EncryptionException("Failed to encrypt data", e);
        }
    }
    
    // 非对称解密
    public String decryptAsymmetric(String ciphertext, PrivateKey privateKey) {
        try {
            Cipher cipher = Cipher.getInstance("RSA");
            cipher.init(Cipher.DECRYPT_MODE, privateKey);
            
            byte[] decryptedBytes = cipher.doFinal(Base64.getDecoder().decode(ciphertext));
            return new String(decryptedBytes);
        } catch (Exception e) {
            throw new DecryptionException("Failed to decrypt data", e);
        }
    }
    
    // 生成密钥对
    public KeyPair generateKeyPair() {
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
            keyPairGenerator.initialize(2048);
            return keyPairGenerator.generateKeyPair();
        } catch (Exception e) {
            throw new KeyGenerationException("Failed to generate key pair", e);
        }
    }
    
    // 生成对称密钥
    public String generateSymmetricKey() {
        try {
            KeyGenerator keyGenerator = KeyGenerator.getInstance(keyAlgorithm);
            keyGenerator.init(keyLength);
            SecretKey secretKey = keyGenerator.generateKey();
            return Base64.getEncoder().encodeToString(secretKey.getEncoded());
        } catch (Exception e) {
            throw new KeyGenerationException("Failed to generate symmetric key", e);
        }
    }
    
    // 数据脱敏
    public String maskSensitiveData(String data, String maskPattern) {
        if (data == null || data.isEmpty()) {
            return data;
        }
        
        // 手机号脱敏
        if (maskPattern.equals("PHONE")) {
            return maskPhone(data);
        }
        
        // 身份证号脱敏
        if (maskPattern.equals("ID_CARD")) {
            return maskIdCard(data);
        }
        
        // 邮箱脱敏
        if (maskPattern.equals("EMAIL")) {
            return maskEmail(data);
        }
        
        // 银行卡号脱敏
        if (maskPattern.equals("BANK_CARD")) {
            return maskBankCard(data);
        }
        
        return data;
    }
    
    // 手机号脱敏
    private String maskPhone(String phone) {
        if (phone.length() >= 11) {
            return phone.substring(0, 3) + "****" + phone.substring(7);
        }
        return phone;
    }
    
    // 身份证号脱敏
    private String maskIdCard(String idCard) {
        if (idCard.length() >= 18) {
            return idCard.substring(0, 6) + "********" + idCard.substring(14);
        }
        return idCard;
    }
    
    // 邮箱脱敏
    private String maskEmail(String email) {
        if (email.contains("@")) {
            String[] parts = email.split("@");
            String username = parts[0];
            String domain = parts[1];
            
            if (username.length() > 2) {
                return username.substring(0, 2) + "***@" + domain;
            }
        }
        return email;
    }
    
    // 银行卡号脱敏
    private String maskBankCard(String bankCard) {
        if (bankCard.length() >= 16) {
            return bankCard.substring(0, 4) + "****" + bankCard.substring(12);
        }
        return bankCard;
    }
}
```

### 4.2 数据脱敏

**数据脱敏服务**：
```java
// 数据脱敏服务
@Service
public class DataMaskingService {
    
    // 字段级脱敏
    public Object maskField(Object value, String fieldName, String maskingRule) {
        if (value == null) {
            return null;
        }
        
        String stringValue = value.toString();
        
        switch (maskingRule) {
            case "FULL_MASK":
                return maskFull(stringValue);
            case "PARTIAL_MASK":
                return maskPartial(stringValue, fieldName);
            case "HASH_MASK":
                return maskHash(stringValue);
            case "ENCRYPT_MASK":
                return maskEncrypt(stringValue);
            default:
                return value;
        }
    }
    
    // 完全脱敏
    private String maskFull(String value) {
        return "***";
    }
    
    // 部分脱敏
    private String maskPartial(String value, String fieldName) {
        if (value.length() <= 2) {
            return "***";
        }
        
        switch (fieldName) {
            case "phone":
                return maskPhone(value);
            case "email":
                return maskEmail(value);
            case "idCard":
                return maskIdCard(value);
            case "bankCard":
                return maskBankCard(value);
            default:
                return value.substring(0, 2) + "***" + value.substring(value.length() - 2);
        }
    }
    
    // 哈希脱敏
    private String maskHash(String value) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            byte[] hash = md.digest(value.getBytes());
            return Base64.getEncoder().encodeToString(hash);
        } catch (Exception e) {
            return "***";
        }
    }
    
    // 加密脱敏
    private String maskEncrypt(String value) {
        // 使用加密算法脱敏
        return encrypt(value, getEncryptionKey());
    }
    
    // 批量脱敏
    public Map<String, Object> maskBatch(Map<String, Object> data, Map<String, String> maskingRules) {
        Map<String, Object> maskedData = new HashMap<>();
        
        for (Map.Entry<String, Object> entry : data.entrySet()) {
            String fieldName = entry.getKey();
            Object value = entry.getValue();
            String maskingRule = maskingRules.get(fieldName);
            
            if (maskingRule != null) {
                maskedData.put(fieldName, maskField(value, fieldName, maskingRule));
            } else {
                maskedData.put(fieldName, value);
            }
        }
        
        return maskedData;
    }
    
    // 动态脱敏
    public Object dynamicMask(Object value, String userRole, String fieldName) {
        // 根据用户角色决定脱敏级别
        if (userRole.equals("ADMIN")) {
            return value; // 管理员不脱敏
        } else if (userRole.equals("USER")) {
            return maskField(value, fieldName, "PARTIAL_MASK");
        } else {
            return maskField(value, fieldName, "FULL_MASK");
        }
    }
}
```

## 五、网络安全防护

### 5.1 防火墙配置

**防火墙配置实现**：
```java
// 防火墙配置
@Component
public class FirewallConfiguration {
    
    // 配置防火墙规则
    public void configureFirewallRules() {
        // 允许的端口
        List<Integer> allowedPorts = Arrays.asList(80, 443, 8080, 8443);
        
        // 允许的IP地址
        List<String> allowedIps = Arrays.asList("192.168.1.0/24", "10.0.0.0/8");
        
        // 禁止的端口
        List<Integer> blockedPorts = Arrays.asList(21, 23, 25, 53, 110, 143, 993, 995);
        
        // 禁止的IP地址
        List<String> blockedIps = Arrays.asList("192.168.2.0/24", "172.16.0.0/12");
        
        // 配置规则
        configureAllowRules(allowedPorts, allowedIps);
        configureBlockRules(blockedPorts, blockedIps);
    }
    
    // 配置允许规则
    private void configureAllowRules(List<Integer> ports, List<String> ips) {
        for (Integer port : ports) {
            for (String ip : ips) {
                addAllowRule(ip, port);
            }
        }
    }
    
    // 配置禁止规则
    private void configureBlockRules(List<Integer> ports, List<String> ips) {
        for (Integer port : ports) {
            for (String ip : ips) {
                addBlockRule(ip, port);
            }
        }
    }
    
    // 添加允许规则
    private void addAllowRule(String ip, int port) {
        FirewallRule rule = new FirewallRule();
        rule.setSourceIp(ip);
        rule.setPort(port);
        rule.setAction(Action.ALLOW);
        rule.setProtocol(Protocol.TCP);
        
        // 应用规则
        applyFirewallRule(rule);
    }
    
    // 添加禁止规则
    private void addBlockRule(String ip, int port) {
        FirewallRule rule = new FirewallRule();
        rule.setSourceIp(ip);
        rule.setPort(port);
        rule.setAction(Action.BLOCK);
        rule.setProtocol(Protocol.TCP);
        
        // 应用规则
        applyFirewallRule(rule);
    }
    
    // 应用防火墙规则
    private void applyFirewallRule(FirewallRule rule) {
        // 实现防火墙规则应用逻辑
        log.info("Applying firewall rule: {} {}:{}", rule.getAction(), rule.getSourceIp(), rule.getPort());
    }
}
```

### 5.2 DDoS防护

**DDoS防护实现**：
```java
// DDoS防护
@Component
public class DdosProtection {
    
    @Autowired
    private RateLimitService rateLimitService;
    
    @Autowired
    private IpBlacklistService ipBlacklistService;
    
    // 检测DDoS攻击
    public boolean detectDdosAttack(HttpServletRequest request) {
        String clientIp = getClientIpAddress(request);
        
        // 检查请求频率
        if (rateLimitService.isRateLimited(clientIp)) {
            return true;
        }
        
        // 检查IP黑名单
        if (ipBlacklistService.isBlacklisted(clientIp)) {
            return true;
        }
        
        // 检查异常请求模式
        if (detectAbnormalPattern(request)) {
            return true;
        }
        
        return false;
    }
    
    // 防护DDoS攻击
    public void protectAgainstDdos(HttpServletRequest request, HttpServletResponse response) {
        String clientIp = getClientIpAddress(request);
        
        // 添加IP到黑名单
        ipBlacklistService.addToBlacklist(clientIp, Duration.ofHours(1));
        
        // 限制请求频率
        rateLimitService.limitRate(clientIp, Duration.ofMinutes(5));
        
        // 返回错误响应
        response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
        response.setHeader("Retry-After", "300");
    }
    
    // 检测异常请求模式
    private boolean detectAbnormalPattern(HttpServletRequest request) {
        String clientIp = getClientIpAddress(request);
        String userAgent = request.getHeader("User-Agent");
        String referer = request.getHeader("Referer");
        
        // 检查User-Agent异常
        if (isAbnormalUserAgent(userAgent)) {
            return true;
        }
        
        // 检查Referer异常
        if (isAbnormalReferer(referer)) {
            return true;
        }
        
        // 检查请求时间间隔异常
        if (isAbnormalRequestInterval(clientIp)) {
            return true;
        }
        
        return false;
    }
    
    // 检查异常User-Agent
    private boolean isAbnormalUserAgent(String userAgent) {
        if (userAgent == null || userAgent.isEmpty()) {
            return true;
        }
        
        // 检查常见的攻击工具User-Agent
        String[] attackPatterns = {
            "sqlmap", "nmap", "nikto", "masscan", "zmap", "nmap", "masscan"
        };
        
        for (String pattern : attackPatterns) {
            if (userAgent.toLowerCase().contains(pattern)) {
                return true;
            }
        }
        
        return false;
    }
    
    // 检查异常Referer
    private boolean isAbnormalReferer(String referer) {
        if (referer == null || referer.isEmpty()) {
            return false;
        }
        
        // 检查可疑的Referer
        String[] suspiciousPatterns = {
            "javascript:", "data:", "vbscript:", "onload=", "onerror="
        };
        
        for (String pattern : suspiciousPatterns) {
            if (referer.toLowerCase().contains(pattern)) {
                return true;
            }
        }
        
        return false;
    }
    
    // 检查异常请求时间间隔
    private boolean isAbnormalRequestInterval(String clientIp) {
        // 检查请求时间间隔是否过短
        long lastRequestTime = getLastRequestTime(clientIp);
        long currentTime = System.currentTimeMillis();
        
        if (currentTime - lastRequestTime < 100) { // 100ms
            return true;
        }
        
        return false;
    }
    
    // 获取客户端IP地址
    private String getClientIpAddress(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }
        
        String xRealIp = request.getHeader("X-Real-IP");
        if (xRealIp != null && !xRealIp.isEmpty()) {
            return xRealIp;
        }
        
        return request.getRemoteAddr();
    }
}
```

## 六、应用安全防护

### 6.1 输入验证

**输入验证实现**：
```java
// 输入验证
@Component
public class InputValidation {
    
    // 验证用户输入
    public ValidationResult validateInput(String input, String fieldName, ValidationRule rule) {
        ValidationResult result = new ValidationResult();
        
        // 检查是否为空
        if (input == null || input.trim().isEmpty()) {
            if (rule.isRequired()) {
                result.addError(fieldName + " is required");
                return result;
            }
            return result;
        }
        
        // 检查长度
        if (input.length() < rule.getMinLength() || input.length() > rule.getMaxLength()) {
            result.addError(fieldName + " length must be between " + rule.getMinLength() + " and " + rule.getMaxLength());
        }
        
        // 检查格式
        if (rule.getPattern() != null && !rule.getPattern().matcher(input).matches()) {
            result.addError(fieldName + " format is invalid");
        }
        
        // 检查特殊字符
        if (containsSpecialCharacters(input, rule.getAllowedCharacters())) {
            result.addError(fieldName + " contains invalid characters");
        }
        
        // 检查SQL注入
        if (containsSqlInjection(input)) {
            result.addError(fieldName + " contains SQL injection attempt");
        }
        
        // 检查XSS攻击
        if (containsXss(input)) {
            result.addError(fieldName + " contains XSS attempt");
        }
        
        return result;
    }
    
    // 检查特殊字符
    private boolean containsSpecialCharacters(String input, String allowedCharacters) {
        if (allowedCharacters == null || allowedCharacters.isEmpty()) {
            return false;
        }
        
        for (char c : input.toCharArray()) {
            if (allowedCharacters.indexOf(c) == -1) {
                return true;
            }
        }
        
        return false;
    }
    
    // 检查SQL注入
    private boolean containsSqlInjection(String input) {
        String[] sqlKeywords = {
            "'", "\"", ";", "--", "/*", "*/", "xp_", "sp_", "exec", "execute",
            "union", "select", "insert", "update", "delete", "drop", "create", "alter"
        };
        
        String lowerInput = input.toLowerCase();
        for (String keyword : sqlKeywords) {
            if (lowerInput.contains(keyword.toLowerCase())) {
                return true;
            }
        }
        
        return false;
    }
    
    // 检查XSS攻击
    private boolean containsXss(String input) {
        String[] xssPatterns = {
            "<script", "</script", "javascript:", "onload=", "onerror=", "onclick=",
            "onmouseover=", "onfocus=", "onblur=", "onchange=", "onsubmit="
        };
        
        String lowerInput = input.toLowerCase();
        for (String pattern : xssPatterns) {
            if (lowerInput.contains(pattern)) {
                return true;
            }
        }
        
        return false;
    }
    
    // 验证邮箱
    public boolean validateEmail(String email) {
        String emailPattern = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$";
        return Pattern.matches(emailPattern, email);
    }
    
    // 验证手机号
    public boolean validatePhone(String phone) {
        String phonePattern = "^1[3-9]\\d{9}$";
        return Pattern.matches(phonePattern, phone);
    }
    
    // 验证身份证号
    public boolean validateIdCard(String idCard) {
        String idCardPattern = "^[1-9]\\d{5}(18|19|20)\\d{2}((0[1-9])|(1[0-2]))(([0-2][1-9])|10|20|30|31)\\d{3}[0-9Xx]$";
        return Pattern.matches(idCardPattern, idCard);
    }
    
    // 验证URL
    public boolean validateUrl(String url) {
        try {
            new URL(url);
            return true;
        } catch (MalformedURLException e) {
            return false;
        }
    }
}
```

### 6.2 输出编码

**输出编码实现**：
```java
// 输出编码
@Component
public class OutputEncoding {
    
    // HTML编码
    public String htmlEncode(String input) {
        if (input == null) {
            return null;
        }
        
        return input.replace("&", "&amp;")
                   .replace("<", "&lt;")
                   .replace(">", "&gt;")
                   .replace("\"", "&quot;")
                   .replace("'", "&#x27;")
                   .replace("/", "&#x2F;");
    }
    
    // HTML解码
    public String htmlDecode(String input) {
        if (input == null) {
            return null;
        }
        
        return input.replace("&amp;", "&")
                   .replace("&lt;", "<")
                   .replace("&gt;", ">")
                   .replace("&quot;", "\"")
                   .replace("&#x27;", "'")
                   .replace("&#x2F;", "/");
    }
    
    // URL编码
    public String urlEncode(String input) {
        if (input == null) {
            return null;
        }
        
        try {
            return URLEncoder.encode(input, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            throw new EncodingException("Failed to URL encode", e);
        }
    }
    
    // URL解码
    public String urlDecode(String input) {
        if (input == null) {
            return null;
        }
        
        try {
            return URLDecoder.decode(input, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            throw new EncodingException("Failed to URL decode", e);
        }
    }
    
    // JavaScript编码
    public String javascriptEncode(String input) {
        if (input == null) {
            return null;
        }
        
        return input.replace("\\", "\\\\")
                   .replace("'", "\\'")
                   .replace("\"", "\\\"")
                   .replace("\n", "\\n")
                   .replace("\r", "\\r")
                   .replace("\t", "\\t");
    }
    
    // SQL编码
    public String sqlEncode(String input) {
        if (input == null) {
            return null;
        }
        
        return input.replace("'", "''")
                   .replace("\\", "\\\\")
                   .replace("\"", "\\\"");
    }
    
    // XML编码
    public String xmlEncode(String input) {
        if (input == null) {
            return null;
        }
        
        return input.replace("&", "&amp;")
                   .replace("<", "&lt;")
                   .replace(">", "&gt;")
                   .replace("\"", "&quot;")
                   .replace("'", "&apos;");
    }
    
    // 自动编码
    public String autoEncode(String input, ContentType contentType) {
        switch (contentType) {
            case HTML:
                return htmlEncode(input);
            case URL:
                return urlEncode(input);
            case JAVASCRIPT:
                return javascriptEncode(input);
            case SQL:
                return sqlEncode(input);
            case XML:
                return xmlEncode(input);
            default:
                return input;
        }
    }
}
```

## 七、安全监控与审计

### 7.1 安全事件监控

**安全事件监控实现**：
```java
// 安全事件监控
@Service
public class SecurityEventMonitoring {
    
    @Autowired
    private SecurityEventRepository securityEventRepository;
    
    @Autowired
    private AlertService alertService;
    
    // 记录安全事件
    public void recordSecurityEvent(SecurityEvent event) {
        // 设置事件时间戳
        event.setTimestamp(LocalDateTime.now());
        
        // 设置事件ID
        event.setEventId(UUID.randomUUID().toString());
        
        // 保存事件
        securityEventRepository.save(event);
        
        // 检查是否需要告警
        if (isHighRiskEvent(event)) {
            sendSecurityAlert(event);
        }
    }
    
    // 检查高风险事件
    private boolean isHighRiskEvent(SecurityEvent event) {
        SecurityEventType eventType = event.getEventType();
        SecurityEventSeverity severity = event.getSeverity();
        
        // 高风险事件类型
        List<SecurityEventType> highRiskTypes = Arrays.asList(
            SecurityEventType.LOGIN_FAILURE,
            SecurityEventType.UNAUTHORIZED_ACCESS,
            SecurityEventType.SQL_INJECTION,
            SecurityEventType.XSS_ATTACK,
            SecurityEventType.DDOS_ATTACK
        );
        
        // 高风险严重级别
        List<SecurityEventSeverity> highRiskSeverities = Arrays.asList(
            SecurityEventSeverity.CRITICAL,
            SecurityEventSeverity.HIGH
        );
        
        return highRiskTypes.contains(eventType) || highRiskSeverities.contains(severity);
    }
    
    // 发送安全告警
    private void sendSecurityAlert(SecurityEvent event) {
        SecurityAlert alert = new SecurityAlert();
        alert.setEventId(event.getEventId());
        alert.setEventType(event.getEventType());
        alert.setSeverity(event.getSeverity());
        alert.setDescription(event.getDescription());
        alert.setTimestamp(event.getTimestamp());
        alert.setSourceIp(event.getSourceIp());
        alert.setUserId(event.getUserId());
        
        alertService.sendSecurityAlert(alert);
    }
    
    // 分析安全事件
    public SecurityEventAnalysis analyzeSecurityEvents(LocalDateTime startTime, LocalDateTime endTime) {
        SecurityEventAnalysis analysis = new SecurityEventAnalysis();
        
        // 获取事件列表
        List<SecurityEvent> events = securityEventRepository.findByTimestampBetween(startTime, endTime);
        
        // 统计事件类型
        Map<SecurityEventType, Long> eventTypeStats = events.stream()
            .collect(Collectors.groupingBy(SecurityEvent::getEventType, Collectors.counting()));
        analysis.setEventTypeStats(eventTypeStats);
        
        // 统计严重级别
        Map<SecurityEventSeverity, Long> severityStats = events.stream()
            .collect(Collectors.groupingBy(SecurityEvent::getSeverity, Collectors.counting()));
        analysis.setSeverityStats(severityStats);
        
        // 统计来源IP
        Map<String, Long> sourceIpStats = events.stream()
            .collect(Collectors.groupingBy(SecurityEvent::getSourceIp, Collectors.counting()));
        analysis.setSourceIpStats(sourceIpStats);
        
        // 统计用户
        Map<String, Long> userStats = events.stream()
            .collect(Collectors.groupingBy(SecurityEvent::getUserId, Collectors.counting()));
        analysis.setUserStats(userStats);
        
        // 计算风险评分
        double riskScore = calculateRiskScore(events);
        analysis.setRiskScore(riskScore);
        
        return analysis;
    }
    
    // 计算风险评分
    private double calculateRiskScore(List<SecurityEvent> events) {
        double totalScore = 0.0;
        
        for (SecurityEvent event : events) {
            double eventScore = calculateEventScore(event);
            totalScore += eventScore;
        }
        
        return totalScore / events.size();
    }
    
    // 计算事件评分
    private double calculateEventScore(SecurityEvent event) {
        double baseScore = 1.0;
        
        // 根据事件类型调整评分
        switch (event.getEventType()) {
            case LOGIN_FAILURE:
                baseScore *= 1.5;
                break;
            case UNAUTHORIZED_ACCESS:
                baseScore *= 2.0;
                break;
            case SQL_INJECTION:
                baseScore *= 3.0;
                break;
            case XSS_ATTACK:
                baseScore *= 2.5;
                break;
            case DDOS_ATTACK:
                baseScore *= 4.0;
                break;
        }
        
        // 根据严重级别调整评分
        switch (event.getSeverity()) {
            case CRITICAL:
                baseScore *= 3.0;
                break;
            case HIGH:
                baseScore *= 2.0;
                break;
            case MEDIUM:
                baseScore *= 1.5;
                break;
            case LOW:
                baseScore *= 1.0;
                break;
        }
        
        return baseScore;
    }
}
```

### 7.2 安全审计

**安全审计实现**：
```java
// 安全审计
@Service
public class SecurityAudit {
    
    @Autowired
    private AuditLogRepository auditLogRepository;
    
    @Autowired
    private SecurityEventRepository securityEventRepository;
    
    // 记录审计日志
    public void recordAuditLog(AuditLog auditLog) {
        // 设置审计信息
        auditLog.setTimestamp(LocalDateTime.now());
        auditLog.setAuditId(UUID.randomUUID().toString());
        
        // 保存审计日志
        auditLogRepository.save(auditLog);
        
        // 检查是否需要安全事件
        if (isSecurityEvent(auditLog)) {
            createSecurityEvent(auditLog);
        }
    }
    
    // 检查是否为安全事件
    private boolean isSecurityEvent(AuditLog auditLog) {
        AuditAction action = auditLog.getAction();
        
        // 安全相关操作
        List<AuditAction> securityActions = Arrays.asList(
            AuditAction.LOGIN,
            AuditAction.LOGOUT,
            AuditAction.ACCESS_DENIED,
            AuditAction.PERMISSION_CHANGE,
            AuditAction.DATA_ACCESS,
            AuditAction.DATA_MODIFICATION,
            AuditAction.DATA_DELETION
        );
        
        return securityActions.contains(action);
    }
    
    // 创建安全事件
    private void createSecurityEvent(AuditLog auditLog) {
        SecurityEvent event = new SecurityEvent();
        event.setEventType(mapToSecurityEventType(auditLog.getAction()));
        event.setSeverity(mapToSecurityEventSeverity(auditLog.getAction()));
        event.setDescription(auditLog.getDescription());
        event.setSourceIp(auditLog.getSourceIp());
        event.setUserId(auditLog.getUserId());
        event.setTimestamp(auditLog.getTimestamp());
        
        securityEventRepository.save(event);
    }
    
    // 映射到安全事件类型
    private SecurityEventType mapToSecurityEventType(AuditAction action) {
        switch (action) {
            case LOGIN:
                return SecurityEventType.LOGIN_SUCCESS;
            case LOGOUT:
                return SecurityEventType.LOGOUT;
            case ACCESS_DENIED:
                return SecurityEventType.UNAUTHORIZED_ACCESS;
            case PERMISSION_CHANGE:
                return SecurityEventType.PERMISSION_CHANGE;
            case DATA_ACCESS:
                return SecurityEventType.DATA_ACCESS;
            case DATA_MODIFICATION:
                return SecurityEventType.DATA_MODIFICATION;
            case DATA_DELETION:
                return SecurityEventType.DATA_DELETION;
            default:
                return SecurityEventType.OTHER;
        }
    }
    
    // 映射到安全事件严重级别
    private SecurityEventSeverity mapToSecurityEventSeverity(AuditAction action) {
        switch (action) {
            case ACCESS_DENIED:
                return SecurityEventSeverity.HIGH;
            case PERMISSION_CHANGE:
                return SecurityEventSeverity.MEDIUM;
            case DATA_DELETION:
                return SecurityEventSeverity.HIGH;
            case DATA_MODIFICATION:
                return SecurityEventSeverity.MEDIUM;
            case DATA_ACCESS:
                return SecurityEventSeverity.LOW;
            default:
                return SecurityEventSeverity.LOW;
        }
    }
    
    // 生成审计报告
    public AuditReport generateAuditReport(LocalDateTime startTime, LocalDateTime endTime) {
        AuditReport report = new AuditReport();
        
        // 获取审计日志
        List<AuditLog> auditLogs = auditLogRepository.findByTimestampBetween(startTime, endTime);
        
        // 统计操作类型
        Map<AuditAction, Long> actionStats = auditLogs.stream()
            .collect(Collectors.groupingBy(AuditLog::getAction, Collectors.counting()));
        report.setActionStats(actionStats);
        
        // 统计用户操作
        Map<String, Long> userStats = auditLogs.stream()
            .collect(Collectors.groupingBy(AuditLog::getUserId, Collectors.counting()));
        report.setUserStats(userStats);
        
        // 统计IP操作
        Map<String, Long> ipStats = auditLogs.stream()
            .collect(Collectors.groupingBy(AuditLog::getSourceIp, Collectors.counting()));
        report.setIpStats(ipStats);
        
        // 统计资源访问
        Map<String, Long> resourceStats = auditLogs.stream()
            .collect(Collectors.groupingBy(AuditLog::getResource, Collectors.counting()));
        report.setResourceStats(resourceStats);
        
        // 计算合规性评分
        double complianceScore = calculateComplianceScore(auditLogs);
        report.setComplianceScore(complianceScore);
        
        return report;
    }
    
    // 计算合规性评分
    private double calculateComplianceScore(List<AuditLog> auditLogs) {
        double totalScore = 0.0;
        int totalCount = auditLogs.size();
        
        for (AuditLog auditLog : auditLogs) {
            double logScore = calculateLogScore(auditLog);
            totalScore += logScore;
        }
        
        return totalCount > 0 ? totalScore / totalCount : 0.0;
    }
    
    // 计算日志评分
    private double calculateLogScore(AuditLog auditLog) {
        double baseScore = 1.0;
        
        // 根据操作类型调整评分
        switch (auditLog.getAction()) {
            case LOGIN:
                baseScore *= 1.0;
                break;
            case LOGOUT:
                baseScore *= 1.0;
                break;
            case ACCESS_DENIED:
                baseScore *= 0.5;
                break;
            case PERMISSION_CHANGE:
                baseScore *= 0.8;
                break;
            case DATA_ACCESS:
                baseScore *= 1.0;
                break;
            case DATA_MODIFICATION:
                baseScore *= 0.9;
                break;
            case DATA_DELETION:
                baseScore *= 0.7;
                break;
        }
        
        return baseScore;
    }
}
```

## 八、安全合规管理

### 8.1 合规性检查

**合规性检查实现**：
```java
// 合规性检查
@Service
public class ComplianceCheck {
    
    @Autowired
    private SecurityPolicyRepository securityPolicyRepository;
    
    @Autowired
    private ComplianceRuleRepository complianceRuleRepository;
    
    // 检查合规性
    public ComplianceReport checkCompliance(String policyId) {
        ComplianceReport report = new ComplianceReport();
        
        // 获取安全策略
        SecurityPolicy policy = securityPolicyRepository.findById(policyId).orElseThrow();
        
        // 获取合规规则
        List<ComplianceRule> rules = complianceRuleRepository.findByPolicyId(policyId);
        
        // 检查每个规则
        List<ComplianceCheckResult> results = new ArrayList<>();
        for (ComplianceRule rule : rules) {
            ComplianceCheckResult result = checkRule(rule);
            results.add(result);
        }
        
        report.setResults(results);
        
        // 计算合规性评分
        double complianceScore = calculateComplianceScore(results);
        report.setComplianceScore(complianceScore);
        
        // 生成合规性建议
        List<ComplianceRecommendation> recommendations = generateRecommendations(results);
        report.setRecommendations(recommendations);
        
        return report;
    }
    
    // 检查规则
    private ComplianceCheckResult checkRule(ComplianceRule rule) {
        ComplianceCheckResult result = new ComplianceCheckResult();
        result.setRuleId(rule.getId());
        result.setRuleName(rule.getName());
        result.setRuleDescription(rule.getDescription());
        
        try {
            // 执行规则检查
            boolean isCompliant = executeRuleCheck(rule);
            result.setCompliant(isCompliant);
            
            if (isCompliant) {
                result.setStatus(ComplianceStatus.COMPLIANT);
                result.setMessage("Rule is compliant");
            } else {
                result.setStatus(ComplianceStatus.NON_COMPLIANT);
                result.setMessage("Rule is not compliant");
            }
            
        } catch (Exception e) {
            result.setStatus(ComplianceStatus.ERROR);
            result.setMessage("Error checking rule: " + e.getMessage());
        }
        
        return result;
    }
    
    // 执行规则检查
    private boolean executeRuleCheck(ComplianceRule rule) {
        ComplianceRuleType ruleType = rule.getType();
        
        switch (ruleType) {
            case PASSWORD_POLICY:
                return checkPasswordPolicy(rule);
            case ACCESS_CONTROL:
                return checkAccessControl(rule);
            case DATA_ENCRYPTION:
                return checkDataEncryption(rule);
            case AUDIT_LOGGING:
                return checkAuditLogging(rule);
            case NETWORK_SECURITY:
                return checkNetworkSecurity(rule);
            default:
                return false;
        }
    }
    
    // 检查密码策略
    private boolean checkPasswordPolicy(ComplianceRule rule) {
        // 检查密码复杂度要求
        int minLength = rule.getMinPasswordLength();
        boolean requireUppercase = rule.isRequireUppercase();
        boolean requireLowercase = rule.isRequireLowercase();
        boolean requireNumbers = rule.isRequireNumbers();
        boolean requireSpecialChars = rule.isRequireSpecialChars();
        
        // 实现密码策略检查逻辑
        return true; // 简化实现
    }
    
    // 检查访问控制
    private boolean checkAccessControl(ComplianceRule rule) {
        // 检查访问控制配置
        boolean hasAccessControl = rule.hasAccessControl();
        boolean hasRoleBasedAccess = rule.hasRoleBasedAccess();
        boolean hasAttributeBasedAccess = rule.hasAttributeBasedAccess();
        
        // 实现访问控制检查逻辑
        return true; // 简化实现
    }
    
    // 检查数据加密
    private boolean checkDataEncryption(ComplianceRule rule) {
        // 检查数据加密配置
        boolean hasDataEncryption = rule.hasDataEncryption();
        String encryptionAlgorithm = rule.getEncryptionAlgorithm();
        int keyLength = rule.getKeyLength();
        
        // 实现数据加密检查逻辑
        return true; // 简化实现
    }
    
    // 检查审计日志
    private boolean checkAuditLogging(ComplianceRule rule) {
        // 检查审计日志配置
        boolean hasAuditLogging = rule.hasAuditLogging();
        int logRetentionDays = rule.getLogRetentionDays();
        boolean hasLogIntegrity = rule.hasLogIntegrity();
        
        // 实现审计日志检查逻辑
        return true; // 简化实现
    }
    
    // 检查网络安全
    private boolean checkNetworkSecurity(ComplianceRule rule) {
        // 检查网络安全配置
        boolean hasFirewall = rule.hasFirewall();
        boolean hasIntrusionDetection = rule.hasIntrusionDetection();
        boolean hasNetworkMonitoring = rule.hasNetworkMonitoring();
        
        // 实现网络安全检查逻辑
        return true; // 简化实现
    }
    
    // 计算合规性评分
    private double calculateComplianceScore(List<ComplianceCheckResult> results) {
        if (results.isEmpty()) {
            return 0.0;
        }
        
        long compliantCount = results.stream()
            .filter(result -> result.getStatus() == ComplianceStatus.COMPLIANT)
            .count();
        
        return (double) compliantCount / results.size() * 100;
    }
    
    // 生成合规性建议
    private List<ComplianceRecommendation> generateRecommendations(List<ComplianceCheckResult> results) {
        List<ComplianceRecommendation> recommendations = new ArrayList<>();
        
        for (ComplianceCheckResult result : results) {
            if (result.getStatus() == ComplianceStatus.NON_COMPLIANT) {
                ComplianceRecommendation recommendation = new ComplianceRecommendation();
                recommendation.setRuleId(result.getRuleId());
                recommendation.setRuleName(result.getRuleName());
                recommendation.setDescription("Fix compliance issue: " + result.getMessage());
                recommendation.setPriority(CompliancePriority.HIGH);
                recommendations.add(recommendation);
            }
        }
        
        return recommendations;
    }
}
```

### 8.2 安全策略管理

**安全策略管理实现**：
```java
// 安全策略管理
@Service
public class SecurityPolicyManagement {
    
    @Autowired
    private SecurityPolicyRepository securityPolicyRepository;
    
    @Autowired
    private ComplianceRuleRepository complianceRuleRepository;
    
    // 创建安全策略
    public SecurityPolicy createSecurityPolicy(SecurityPolicy policy) {
        // 设置策略信息
        policy.setId(UUID.randomUUID().toString());
        policy.setCreatedAt(LocalDateTime.now());
        policy.setUpdatedAt(LocalDateTime.now());
        policy.setStatus(SecurityPolicyStatus.ACTIVE);
        
        // 保存策略
        SecurityPolicy savedPolicy = securityPolicyRepository.save(policy);
        
        // 创建默认合规规则
        createDefaultComplianceRules(savedPolicy);
        
        return savedPolicy;
    }
    
    // 更新安全策略
    public SecurityPolicy updateSecurityPolicy(String policyId, SecurityPolicy policy) {
        SecurityPolicy existingPolicy = securityPolicyRepository.findById(policyId).orElseThrow();
        
        // 更新策略信息
        existingPolicy.setName(policy.getName());
        existingPolicy.setDescription(policy.getDescription());
        existingPolicy.setUpdatedAt(LocalDateTime.now());
        
        // 保存更新
        return securityPolicyRepository.save(existingPolicy);
    }
    
    // 删除安全策略
    public void deleteSecurityPolicy(String policyId) {
        SecurityPolicy policy = securityPolicyRepository.findById(policyId).orElseThrow();
        
        // 删除相关合规规则
        complianceRuleRepository.deleteByPolicyId(policyId);
        
        // 删除策略
        securityPolicyRepository.delete(policy);
    }
    
    // 创建默认合规规则
    private void createDefaultComplianceRules(SecurityPolicy policy) {
        List<ComplianceRule> defaultRules = Arrays.asList(
            createPasswordPolicyRule(policy),
            createAccessControlRule(policy),
            createDataEncryptionRule(policy),
            createAuditLoggingRule(policy),
            createNetworkSecurityRule(policy)
        );
        
        complianceRuleRepository.saveAll(defaultRules);
    }
    
    // 创建密码策略规则
    private ComplianceRule createPasswordPolicyRule(SecurityPolicy policy) {
        ComplianceRule rule = new ComplianceRule();
        rule.setId(UUID.randomUUID().toString());
        rule.setPolicyId(policy.getId());
        rule.setName("Password Policy");
        rule.setDescription("Password complexity requirements");
        rule.setType(ComplianceRuleType.PASSWORD_POLICY);
        rule.setMinPasswordLength(8);
        rule.setRequireUppercase(true);
        rule.setRequireLowercase(true);
        rule.setRequireNumbers(true);
        rule.setRequireSpecialChars(true);
        rule.setPasswordExpiryDays(90);
        rule.setPasswordHistoryCount(5);
        return rule;
    }
    
    // 创建访问控制规则
    private ComplianceRule createAccessControlRule(SecurityPolicy policy) {
        ComplianceRule rule = new ComplianceRule();
        rule.setId(UUID.randomUUID().toString());
        rule.setPolicyId(policy.getId());
        rule.setName("Access Control");
        rule.setDescription("Access control requirements");
        rule.setType(ComplianceRuleType.ACCESS_CONTROL);
        rule.setHasAccessControl(true);
        rule.setHasRoleBasedAccess(true);
        rule.setHasAttributeBasedAccess(false);
        rule.setHasMultiFactorAuthentication(true);
        return rule;
    }
    
    // 创建数据加密规则
    private ComplianceRule createDataEncryptionRule(SecurityPolicy policy) {
        ComplianceRule rule = new ComplianceRule();
        rule.setId(UUID.randomUUID().toString());
        rule.setPolicyId(policy.getId());
        rule.setName("Data Encryption");
        rule.setDescription("Data encryption requirements");
        rule.setType(ComplianceRuleType.DATA_ENCRYPTION);
        rule.setHasDataEncryption(true);
        rule.setEncryptionAlgorithm("AES-256");
        rule.setKeyLength(256);
        rule.setHasKeyManagement(true);
        return rule;
    }
    
    // 创建审计日志规则
    private ComplianceRule createAuditLoggingRule(SecurityPolicy policy) {
        ComplianceRule rule = new ComplianceRule();
        rule.setId(UUID.randomUUID().toString());
        rule.setPolicyId(policy.getId());
        rule.setName("Audit Logging");
        rule.setDescription("Audit logging requirements");
        rule.setType(ComplianceRuleType.AUDIT_LOGGING);
        rule.setHasAuditLogging(true);
        rule.setLogRetentionDays(365);
        rule.setHasLogIntegrity(true);
        rule.setHasLogMonitoring(true);
        return rule;
    }
    
    // 创建网络安全规则
    private ComplianceRule createNetworkSecurityRule(SecurityPolicy policy) {
        ComplianceRule rule = new ComplianceRule();
        rule.setId(UUID.randomUUID().toString());
        rule.setPolicyId(policy.getId());
        rule.setName("Network Security");
        rule.setDescription("Network security requirements");
        rule.setType(ComplianceRuleType.NETWORK_SECURITY);
        rule.setHasFirewall(true);
        rule.setHasIntrusionDetection(true);
        rule.setHasNetworkMonitoring(true);
        rule.setHasDdosProtection(true);
        return rule;
    }
}
```

## 九、安全架构实践

### 9.1 安全架构设计

**安全架构设计实现**：
```java
// 安全架构设计
@Component
public class SecurityArchitectureDesign {
    
    // 设计安全架构
    public SecurityArchitecture designSecurityArchitecture(ApplicationProfile profile) {
        SecurityArchitecture architecture = new SecurityArchitecture();
        
        // 设计认证层
        AuthenticationLayer authLayer = designAuthenticationLayer(profile);
        architecture.setAuthenticationLayer(authLayer);
        
        // 设计授权层
        AuthorizationLayer authzLayer = designAuthorizationLayer(profile);
        architecture.setAuthorizationLayer(authzLayer);
        
        // 设计数据保护层
        DataProtectionLayer dataLayer = designDataProtectionLayer(profile);
        architecture.setDataProtectionLayer(dataLayer);
        
        // 设计网络安全层
        NetworkSecurityLayer networkLayer = designNetworkSecurityLayer(profile);
        architecture.setNetworkSecurityLayer(networkLayer);
        
        // 设计应用安全层
        ApplicationSecurityLayer appLayer = designApplicationSecurityLayer(profile);
        architecture.setApplicationSecurityLayer(appLayer);
        
        // 设计监控审计层
        MonitoringAuditLayer monitorLayer = designMonitoringAuditLayer(profile);
        architecture.setMonitoringAuditLayer(monitorLayer);
        
        return architecture;
    }
    
    // 设计认证层
    private AuthenticationLayer designAuthenticationLayer(ApplicationProfile profile) {
        AuthenticationLayer layer = new AuthenticationLayer();
        
        // 选择认证方式
        if (profile.isEnterpriseApplication()) {
            layer.setAuthenticationMethod(AuthenticationMethod.SAML);
        } else if (profile.isCloudApplication()) {
            layer.setAuthenticationMethod(AuthenticationMethod.OAUTH2);
        } else {
            layer.setAuthenticationMethod(AuthenticationMethod.JWT);
        }
        
        // 配置多因素认证
        layer.setMultiFactorAuthentication(profile.isHighSecurityRequired());
        
        // 配置密码策略
        layer.setPasswordPolicy(createPasswordPolicy(profile));
        
        // 配置会话管理
        layer.setSessionManagement(createSessionManagement(profile));
        
        return layer;
    }
    
    // 设计授权层
    private AuthorizationLayer designAuthorizationLayer(ApplicationProfile profile) {
        AuthorizationLayer layer = new AuthorizationLayer();
        
        // 选择授权模型
        if (profile.isComplexAuthorizationRequired()) {
            layer.setAuthorizationModel(AuthorizationModel.ABAC);
        } else {
            layer.setAuthorizationModel(AuthorizationModel.RBAC);
        }
        
        // 配置权限管理
        layer.setPermissionManagement(createPermissionManagement(profile));
        
        // 配置访问控制
        layer.setAccessControl(createAccessControl(profile));
        
        return layer;
    }
    
    // 设计数据保护层
    private DataProtectionLayer designDataProtectionLayer(ApplicationProfile profile) {
        DataProtectionLayer layer = new DataProtectionLayer();
        
        // 配置数据加密
        layer.setDataEncryption(createDataEncryption(profile));
        
        // 配置数据脱敏
        layer.setDataMasking(createDataMasking(profile));
        
        // 配置数据备份
        layer.setDataBackup(createDataBackup(profile));
        
        return layer;
    }
    
    // 设计网络安全层
    private NetworkSecurityLayer designNetworkSecurityLayer(ApplicationProfile profile) {
        NetworkSecurityLayer layer = new NetworkSecurityLayer();
        
        // 配置防火墙
        layer.setFirewall(createFirewall(profile));
        
        // 配置入侵检测
        layer.setIntrusionDetection(createIntrusionDetection(profile));
        
        // 配置DDoS防护
        layer.setDdosProtection(createDdosProtection(profile));
        
        return layer;
    }
    
    // 设计应用安全层
    private ApplicationSecurityLayer designApplicationSecurityLayer(ApplicationProfile profile) {
        ApplicationSecurityLayer layer = new ApplicationSecurityLayer();
        
        // 配置输入验证
        layer.setInputValidation(createInputValidation(profile));
        
        // 配置输出编码
        layer.setOutputEncoding(createOutputEncoding(profile));
        
        // 配置安全头
        layer.setSecurityHeaders(createSecurityHeaders(profile));
        
        return layer;
    }
    
    // 设计监控审计层
    private MonitoringAuditLayer designMonitoringAuditLayer(ApplicationProfile profile) {
        MonitoringAuditLayer layer = new MonitoringAuditLayer();
        
        // 配置安全监控
        layer.setSecurityMonitoring(createSecurityMonitoring(profile));
        
        // 配置审计日志
        layer.setAuditLogging(createAuditLogging(profile));
        
        // 配置告警
        layer.setAlerting(createAlerting(profile));
        
        return layer;
    }
}
```

### 9.2 安全实施指南

**安全实施指南实现**：
```java
// 安全实施指南
@Component
public class SecurityImplementationGuide {
    
    // 生成安全实施计划
    public SecurityImplementationPlan generateImplementationPlan(SecurityArchitecture architecture) {
        SecurityImplementationPlan plan = new SecurityImplementationPlan();
        
        // 生成实施阶段
        List<ImplementationPhase> phases = generateImplementationPhases(architecture);
        plan.setPhases(phases);
        
        // 生成实施时间表
        ImplementationTimeline timeline = generateImplementationTimeline(phases);
        plan.setTimeline(timeline);
        
        // 生成资源需求
        ResourceRequirement resourceRequirement = generateResourceRequirement(phases);
        plan.setResourceRequirement(resourceRequirement);
        
        // 生成风险评估
        RiskAssessment riskAssessment = generateRiskAssessment(phases);
        plan.setRiskAssessment(riskAssessment);
        
        return plan;
    }
    
    // 生成实施阶段
    private List<ImplementationPhase> generateImplementationPhases(SecurityArchitecture architecture) {
        List<ImplementationPhase> phases = new ArrayList<>();
        
        // 第一阶段：基础安全
        ImplementationPhase phase1 = new ImplementationPhase();
        phase1.setPhaseNumber(1);
        phase1.setPhaseName("基础安全");
        phase1.setDescription("实施基础安全措施");
        phase1.setTasks(Arrays.asList(
            "配置防火墙",
            "实施访问控制",
            "配置审计日志",
            "实施数据加密"
        ));
        phase1.setDuration(Duration.ofWeeks(2));
        phases.add(phase1);
        
        // 第二阶段：认证授权
        ImplementationPhase phase2 = new ImplementationPhase();
        phase2.setPhaseNumber(2);
        phase2.setPhaseName("认证授权");
        phase2.setDescription("实施认证授权系统");
        phase2.setTasks(Arrays.asList(
            "实施用户认证",
            "配置权限管理",
            "实施单点登录",
            "配置多因素认证"
        ));
        phase2.setDuration(Duration.ofWeeks(3));
        phases.add(phase2);
        
        // 第三阶段：应用安全
        ImplementationPhase phase3 = new ImplementationPhase();
        phase3.setPhaseNumber(3);
        phase3.setPhaseName("应用安全");
        phase3.setDescription("实施应用安全措施");
        phase3.setTasks(Arrays.asList(
            "实施输入验证",
            "配置输出编码",
            "实施安全头",
            "配置API安全"
        ));
        phase3.setDuration(Duration.ofWeeks(2));
        phases.add(phase3);
        
        // 第四阶段：监控审计
        ImplementationPhase phase4 = new ImplementationPhase();
        phase4.setPhaseNumber(4);
        phase4.setPhaseName("监控审计");
        phase4.setDescription("实施监控审计系统");
        phase4.setTasks(Arrays.asList(
            "配置安全监控",
            "实施告警系统",
            "配置合规检查",
            "实施安全培训"
        ));
        phase4.setDuration(Duration.ofWeeks(2));
        phases.add(phase4);
        
        return phases;
    }
    
    // 生成实施时间表
    private ImplementationTimeline generateImplementationTimeline(List<ImplementationPhase> phases) {
        ImplementationTimeline timeline = new ImplementationTimeline();
        
        LocalDateTime startDate = LocalDateTime.now();
        LocalDateTime currentDate = startDate;
        
        for (ImplementationPhase phase : phases) {
            ImplementationPhaseTimeline phaseTimeline = new ImplementationPhaseTimeline();
            phaseTimeline.setPhase(phase);
            phaseTimeline.setStartDate(currentDate);
            phaseTimeline.setEndDate(currentDate.plus(phase.getDuration()));
            
            timeline.addPhaseTimeline(phaseTimeline);
            currentDate = currentDate.plus(phase.getDuration());
        }
        
        timeline.setTotalDuration(Duration.between(startDate, currentDate));
        return timeline;
    }
    
    // 生成资源需求
    private ResourceRequirement generateResourceRequirement(List<ImplementationPhase> phases) {
        ResourceRequirement requirement = new ResourceRequirement();
        
        // 计算人力需求
        int totalPersonDays = phases.stream()
            .mapToInt(phase -> phase.getTasks().size() * 2) // 每个任务2人天
            .sum();
        requirement.setPersonDays(totalPersonDays);
        
        // 计算技术需求
        List<String> technologies = Arrays.asList(
            "防火墙设备",
            "认证服务器",
            "加密软件",
            "监控工具",
            "审计系统"
        );
        requirement.setTechnologies(technologies);
        
        // 计算预算需求
        double totalBudget = totalPersonDays * 1000; // 每人天1000元
        requirement.setBudget(totalBudget);
        
        return requirement;
    }
    
    // 生成风险评估
    private RiskAssessment generateRiskAssessment(List<ImplementationPhase> phases) {
        RiskAssessment assessment = new RiskAssessment();
        
        List<Risk> risks = new ArrayList<>();
        
        // 技术风险
        Risk technicalRisk = new Risk();
        technicalRisk.setRiskType(RiskType.TECHNICAL);
        technicalRisk.setDescription("技术实施风险");
        technicalRisk.setProbability(0.3);
        technicalRisk.setImpact(0.7);
        technicalRisk.setMitigation("技术培训和专家支持");
        risks.add(technicalRisk);
        
        // 时间风险
        Risk timeRisk = new Risk();
        timeRisk.setRiskType(RiskType.TIME);
        timeRisk.setDescription("实施时间风险");
        timeRisk.setProbability(0.4);
        timeRisk.setImpact(0.6);
        timeRisk.setMitigation("合理的时间规划和缓冲时间");
        risks.add(timeRisk);
        
        // 资源风险
        Risk resourceRisk = new Risk();
        resourceRisk.setRiskType(RiskType.RESOURCE);
        resourceRisk.setDescription("资源不足风险");
        resourceRisk.setProbability(0.2);
        resourceRisk.setImpact(0.8);
        resourceRisk.setMitigation("提前准备资源和备用方案");
        risks.add(resourceRisk);
        
        assessment.setRisks(risks);
        
        // 计算总体风险
        double overallRisk = risks.stream()
            .mapToDouble(risk -> risk.getProbability() * risk.getImpact())
            .average()
            .orElse(0.0);
        assessment.setOverallRisk(overallRisk);
        
        return assessment;
    }
}
```

## 十、高频面试题

### Q1：如何设计一个安全架构？

**核心原理**：
安全架构设计基于"纵深防御、零信任、最小权限"的核心理念，通过多层安全防护体系，确保系统在机密性、完整性、可用性等方面的安全要求。其本质是在安全防护、系统性能、用户体验之间找到最优平衡点，建立可持续的安全防护能力。

数学上，安全架构可以建模为：S(A) = Σ(L_i × P_i × E_i)，其中S(A)是架构安全度，L_i是第i层防护强度，P_i是第i层防护概率，E_i是第i层防护效果。通过多层防护的协同作用，可以最大化整体安全效果。

**安全架构设计步骤**：
1. **威胁建模**：全面识别系统面临的安全威胁
   - **威胁识别**：识别外部威胁、内部威胁、供应链威胁
   - **威胁分析**：分析威胁来源、攻击路径、影响范围
   - **风险评估**：评估威胁概率、影响程度、风险等级
   - **威胁分类**：按威胁类型、攻击方式、影响范围分类

2. **安全需求分析**：确定安全需求和约束条件
   - **合规要求**：GDPR、SOX、PCI-DSS等合规要求
   - **业务需求**：业务安全需求、用户隐私保护
   - **技术约束**：技术栈限制、性能要求、成本约束
   - **运营约束**：运维能力、人员技能、工具支持

3. **安全架构设计**：设计多层安全防护体系
   - **网络层安全**：防火墙、入侵检测、DDoS防护
   - **应用层安全**：身份认证、授权控制、输入验证
   - **数据层安全**：数据加密、访问控制、审计监控
   - **运维层安全**：安全监控、事件响应、合规管理

4. **安全技术选型**：选择合适的安全技术和工具
   - **认证技术**：OAuth2.0、JWT、SAML、多因子认证
   - **加密技术**：AES、RSA、ECC、TLS/SSL
   - **监控技术**：SIEM、SOC、威胁情报、行为分析
   - **防护技术**：WAF、IPS、EDR、DLP

**应用场景**：
1. **金融系统**：高安全要求，需要严格的身份认证和数据保护
2. **电商平台**：用户隐私保护，需要数据脱敏和访问控制
3. **政府系统**：合规要求严格，需要审计和监控
4. **医疗系统**：患者隐私保护，需要HIPAA合规

**实战经验**：
在金融支付系统安全架构设计中，我们采用了"4+3+2+1"安全模型：4个核心安全层（网络层、应用层、数据层、运维层）、3个安全能力（认证授权、数据保护、威胁防护）、2个安全机制（监控审计、事件响应）、1个安全体系（安全治理）。

通过实施零信任架构，所有用户和设备都需要验证身份和权限；通过数据加密和脱敏，保护敏感数据安全；通过多层防护和监控，实现威胁检测和响应。系统通过了PCI-DSS认证，安全事件响应时间从2小时降低到15分钟。

**权衡取舍**：
- **安全性 vs 性能**：高安全性可能影响性能，需要平衡安全和性能
- **安全性 vs 易用性**：复杂安全措施可能影响用户体验
- **成本 vs 安全**：高安全投入成本高，需要评估ROI
- **合规 vs 创新**：严格合规可能限制技术创新

**常见追问**：
1. 追问：如何平衡安全性和性能？→ 回答：采用分层安全架构，核心数据强保护，非核心数据适度保护，使用缓存和CDN优化性能。
2. 追问：安全架构如何应对新威胁？→ 回答：建立威胁情报体系，定期安全评估，持续安全更新，建立应急响应机制。

**踩坑经验**：
- 坑1：安全措施过于复杂导致系统性能下降。解决：采用分层安全架构，核心功能强保护，非核心功能适度保护。
- 坑2：忽视内部威胁导致安全事件。解决：建立内部威胁检测机制，实施最小权限原则，加强员工安全意识培训。
- 坑3：安全架构缺乏监控导致威胁检测滞后。解决：建立安全监控体系，实施实时威胁检测，建立安全事件响应流程。

### Q2：常见的安全威胁有哪些？

**核心原理**：
安全威胁是系统面临的各种潜在风险，基于"攻击者视角、系统弱点、业务影响"的分析框架，通过威胁建模和风险评估，识别和应对各种安全威胁。威胁分析的核心是理解攻击者的动机、能力和攻击路径，建立相应的防护措施。

数学上，威胁风险R(T) = P(T) × I(T) × V(T)，其中P(T)是威胁概率，I(T)是威胁影响，V(T)是系统脆弱性。通过威胁风险评估，可以优先处理高风险威胁。

**常见安全威胁详解**：
1. **身份认证威胁**：密码破解、会话劫持、身份伪造
   - **密码破解**：暴力破解、字典攻击、彩虹表攻击
   - **会话劫持**：会话固定、会话劫持、CSRF攻击
   - **身份伪造**：身份冒用、凭证伪造、社会工程学
   - **多因子绕过**：SIM卡劫持、短信验证码拦截

2. **授权威胁**：权限提升、越权访问、权限滥用
   - **权限提升**：水平权限提升、垂直权限提升
   - **越权访问**：IDOR、水平越权、垂直越权
   - **权限滥用**：权限过度、权限泄露、权限继承
   - **特权滥用**：管理员权限滥用、系统权限滥用

3. **数据威胁**：数据泄露、数据篡改、数据丢失
   - **数据泄露**：SQL注入、数据导出、内存泄露
   - **数据篡改**：数据污染、数据伪造、数据重放
   - **数据丢失**：数据删除、数据损坏、备份丢失
   - **数据泄露**：内部泄露、外部泄露、供应链泄露

4. **网络威胁**：DDoS攻击、中间人攻击、网络监听
   - **DDoS攻击**：流量攻击、应用攻击、协议攻击
   - **中间人攻击**：ARP欺骗、DNS劫持、SSL剥离
   - **网络监听**：数据包捕获、流量分析、协议分析
   - **网络入侵**：端口扫描、漏洞利用、后门植入

5. **应用威胁**：SQL注入、XSS攻击、CSRF攻击
   - **SQL注入**：联合查询注入、布尔盲注、时间盲注
   - **XSS攻击**：反射型XSS、存储型XSS、DOM型XSS
   - **CSRF攻击**：跨站请求伪造、状态改变攻击
   - **文件上传**：恶意文件上传、路径遍历、代码执行

6. **系统威胁**：恶意软件、系统漏洞、后门程序
   - **恶意软件**：病毒、木马、蠕虫、勒索软件
   - **系统漏洞**：缓冲区溢出、整数溢出、格式化字符串
   - **后门程序**：隐藏后门、Rootkit、持久化攻击
   - **供应链攻击**：恶意依赖、代码注入、证书伪造

**应用场景**：
1. **Web应用**：主要面临SQL注入、XSS、CSRF等应用层威胁
2. **移动应用**：主要面临恶意软件、数据泄露、权限滥用等威胁
3. **云服务**：主要面临数据泄露、配置错误、共享责任等威胁
4. **IoT设备**：主要面临设备劫持、数据泄露、DDoS等威胁

**实战经验**：
在电商平台安全防护中，我们建立了威胁情报体系，实时监控各种安全威胁：通过WAF防护SQL注入和XSS攻击，通过DDoS防护应对流量攻击，通过数据加密保护敏感数据，通过访问控制防止越权访问。

在2023年，我们成功防护了1000+次SQL注入攻击、500+次XSS攻击、50+次DDoS攻击，数据泄露事件0次，系统可用性达到99.99%。通过威胁情报和机器学习，威胁检测准确率达到95%，误报率控制在5%以内。

**权衡取舍**：
- **防护 vs 性能**：强防护可能影响性能，需要平衡防护和性能
- **检测 vs 误报**：高检测率可能增加误报，需要平衡检测和误报
- **成本 vs 安全**：高安全投入成本高，需要评估成本效益
- **合规 vs 创新**：严格合规可能限制技术创新

**常见追问**：
1. 追问：如何建立威胁情报体系？→ 回答：收集外部威胁情报，建立内部威胁检测，使用机器学习分析威胁模式，建立威胁情报共享机制。
2. 追问：如何应对零日漏洞？→ 回答：建立漏洞管理流程，实施深度防御，使用行为检测，建立应急响应机制。

**踩坑经验**：
- 坑1：忽视内部威胁导致安全事件。解决：建立内部威胁检测机制，实施最小权限原则，加强员工安全意识培训。
- 坑2：安全防护过于依赖单一技术导致防护失效。解决：采用多层防护架构，使用多种安全技术，建立防护冗余。
- 坑3：威胁检测规则过于严格导致误报率高。解决：优化检测规则，使用机器学习降低误报，建立威胁情报验证。

### Q3：如何实现数据安全保护？

**核心原理**：
数据安全保护基于"数据分类、分级保护、全程加密"的核心理念，通过数据识别、数据加密、访问控制、审计监控等技术手段，确保数据在存储、传输、处理、销毁全生命周期的安全。其本质是在数据可用性、数据安全性、合规要求之间找到最优平衡点。

数学上，数据安全度S(D) = Σ(E_i × A_i × M_i)，其中E_i是第i层加密强度，A_i是第i层访问控制强度，M_i是第i层监控强度。通过多层数据保护措施，可以最大化数据安全效果。

**数据安全保护措施**：
1. **数据加密**：传输加密、存储加密、端到端加密
   - **传输加密**：TLS/SSL、VPN、专线加密
   - **存储加密**：数据库加密、文件系统加密、磁盘加密
   - **端到端加密**：应用层加密、字段级加密、同态加密
   - **密钥管理**：密钥生成、密钥分发、密钥轮换、密钥销毁

2. **数据脱敏**：敏感数据脱敏、数据匿名化
   - **静态脱敏**：数据替换、数据遮蔽、数据泛化
   - **动态脱敏**：实时脱敏、按需脱敏、角色脱敏
   - **数据匿名化**：k-匿名、l-多样性、t-接近性
   - **差分隐私**：隐私预算、噪声添加、隐私保护

3. **数据备份**：定期备份、异地备份、备份加密
   - **备份策略**：全量备份、增量备份、差异备份
   - **备份存储**：本地备份、异地备份、云备份
   - **备份加密**：备份数据加密、备份传输加密
   - **备份恢复**：快速恢复、完整恢复、部分恢复

4. **访问控制**：基于角色的访问控制、数据分级保护
   - **RBAC**：角色定义、权限分配、权限继承
   - **ABAC**：属性定义、策略规则、动态授权
   - **数据分级**：公开、内部、机密、绝密
   - **最小权限**：最小权限原则、权限审查、权限回收

5. **审计监控**：数据访问审计、异常行为监控
   - **访问审计**：访问日志、操作记录、审计轨迹
   - **行为监控**：异常检测、行为分析、风险评分
   - **实时告警**：异常告警、风险告警、合规告警
   - **事件响应**：事件分类、响应流程、处置记录

6. **合规管理**：数据保护法规遵循、隐私保护
   - **法规遵循**：GDPR、CCPA、PIPEDA、个保法
   - **隐私保护**：隐私设计、隐私影响评估、隐私审计
   - **数据治理**：数据分类、数据质量、数据生命周期
   - **合规检查**：合规评估、合规监控、合规报告

**应用场景**：
1. **金融数据**：高安全要求，需要强加密和严格访问控制
2. **医疗数据**：患者隐私保护，需要HIPAA合规和数据脱敏
3. **个人数据**：隐私保护，需要GDPR合规和用户同意
4. **商业数据**：商业秘密保护，需要数据分级和访问控制

**实战经验**：
在电商平台数据安全保护中，我们实施了"3+2+1"数据保护模型：3个核心保护层（加密层、访问控制层、监控层）、2个支撑机制（备份恢复、合规管理）、1个治理体系（数据治理）。

通过AES-256加密保护存储数据，TLS 1.3加密保护传输数据，字段级加密保护敏感字段；通过RBAC+ABAC实现细粒度访问控制；通过数据脱敏保护用户隐私；通过实时监控检测异常访问。系统通过了SOC2认证，数据泄露事件0次，数据恢复时间RTO<4小时。

**权衡取舍**：
- **安全性 vs 性能**：强加密可能影响性能，需要平衡安全和性能
- **隐私 vs 功能**：严格隐私保护可能限制功能，需要平衡隐私和功能
- **合规 vs 成本**：严格合规成本高，需要评估合规成本
- **可用性 vs 安全性**：高安全性可能影响可用性

**常见追问**：
1. 追问：如何选择数据加密算法？→ 回答：根据数据敏感级别选择加密算法，敏感数据使用AES-256，一般数据使用AES-128，考虑性能和安全性平衡。
2. 追问：数据脱敏如何保证数据可用性？→ 回答：使用可逆脱敏技术，保持数据格式和统计特性，支持数据分析和测试。

**踩坑经验**：
- 坑1：加密密钥管理不当导致数据无法解密。解决：建立完善的密钥管理体系，实施密钥备份和恢复机制。
- 坑2：数据脱敏过度导致数据失去分析价值。解决：使用智能脱敏技术，保持数据统计特性和分析价值。
- 坑3：忽视数据销毁导致数据泄露风险。解决：建立数据销毁流程，使用安全删除技术，定期销毁过期数据。

---

**关键字**：安全架构、认证授权、API安全、数据安全、网络安全、应用安全、安全监控、安全审计、安全合规、OAuth2.0、JWT、RBAC、数据加密、数据脱敏、防火墙、DDoS防护、输入验证、输出编码、安全事件、合规性检查、安全策略、安全实施、安全威胁、安全防护、安全技术、安全实践、安全经验、安全案例、安全总结、安全指南、安全手册、安全教程、安全培训、安全认证、安全考试、安全面试、安全题目、安全答案、安全解析、安全详解、安全深入、安全全面、安全系统、安全完整、安全详细、安全专业、安全高级、安全专家、安全大师、安全权威、安全标准、安全规范、安全流程、安全方法、安全工具、安全框架

