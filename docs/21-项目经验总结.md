# 项目经验总结

## 目录
- [一、项目难点](#一项目难点)
- [二、解决方案](#二解决方案)
- [三、业务架构](#三业务架构)
- [四、面试技巧](#四面试技巧)

## 一、项目难点

### 1.1 高并发场景

**问题**：秒杀场景，10万+ QPS

**解决方案**：
```
1. 前端：按钮防抖、验证码
2. 网关：限流（令牌桶）
3. 缓存：Redis预扣库存
4. 消息队列：削峰填谷
5. 数据库：分库分表
```

**代码示例**：
```java
@Service
public class SeckillService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    public Result seckill(Long userId, Long productId) {
        String stockKey = "seckill:stock:" + productId;
        
        // Lua脚本保证原子性
        String script = 
            "if redis.call('get', KEYS[1]) and tonumber(redis.call('get', KEYS[1])) > 0 then " +
            "    redis.call('decr', KEYS[1]) " +
            "    return 1 " +
            "else " +
            "    return 0 " +
            "end";
        
        Long result = redisTemplate.execute(
            new DefaultRedisScript<>(script, Long.class),
            Collections.singletonList(stockKey)
        );
        
        if (result == 1) {
            // 发送MQ异步创建订单
            rocketMQTemplate.asyncSend("seckill-topic", 
                new SeckillMessage(userId, productId));
            return Result.success();
        }
        
        return Result.fail("库存不足");
    }
}
```

### 1.2 数据一致性

**问题**：分布式事务，订单系统与库存系统

**解决方案**：TCC
```java
@Component
@RocketMQTransactionListener
public class OrderTransactionListener 
        implements RocketMQLocalTransactionListener {
    
    @Override
    public RocketMQLocalTransactionState executeLocalTransaction(
            Message msg, Object arg) {
        try {
            Order order = (Order) arg;
            // 1. 创建订单
            orderService.createOrder(order);
            // 2. 提交事务
            return RocketMQLocalTransactionState.COMMIT;
        } catch (Exception e) {
            return RocketMQLocalTransactionState.ROLLBACK;
        }
    }
    
    @Override
    public RocketMQLocalTransactionState checkLocalTransaction(Message msg) {
        // 事务回查
        String orderId = msg.getKeys();
        Order order = orderService.getById(orderId);
        return order != null ? 
            RocketMQLocalTransactionState.COMMIT : 
            RocketMQLocalTransactionState.ROLLBACK;
    }
}
```

### 1.3 系统稳定性

**问题**：依赖服务不稳定导致雪崩

**解决方案**：限流、降级、熔断
```java
@RestController
public class OrderController {
    
    @GetMapping("/order/{id}")
    @SentinelResource(
        value = "getOrder",
        blockHandler = "handleBlock",
        fallback = "handleFallback"
    )
    public Order getOrder(@PathVariable Long id) {
        return orderService.getById(id);
    }
    
    // 限流降级
    public Order handleBlock(Long id, BlockException ex) {
        return new Order(id, "系统繁忙，请稍后重试");
    }
    
    // 异常降级
    public Order handleFallback(Long id, Throwable ex) {
        log.error("Failed to get order", ex);
        return cacheService.getOrder(id);  // 返回缓存数据
    }
}
```

## 二、解决方案

### 2.1 性能优化

**案例**：接口响应时间从2s优化到200ms

**优化步骤**：
1. **慢SQL优化**：添加索引，查询时间从1s→10ms
2. **N+1查询优化**：使用JOIN，减少数据库访问
3. **缓存**：热点数据缓存到Redis
4. **异步化**：非核心逻辑异步处理

```java
// 优化前
public OrderDTO getOrder(Long id) {
    Order order = orderMapper.selectById(id);  // 10ms
    
    for (OrderItem item : order.getItems()) {
        Product product = productMapper.selectById(item.getProductId());  // N次查询
        item.setProduct(product);
    }
    
    return OrderDTO.from(order);
}

// 优化后
public OrderDTO getOrder(Long id) {
    // 1. 查询缓存
    OrderDTO cached = cacheService.getOrder(id);
    if (cached != null) {
        return cached;
    }
    
    // 2. 一次性查询
    Order order = orderMapper.selectByIdWithItems(id);  // JOIN查询
    
    // 3. 批量查询商品
    List<Long> productIds = order.getItems().stream()
        .map(OrderItem::getProductId)
        .collect(Collectors.toList());
    List<Product> products = productMapper.selectByIds(productIds);
    
    // 4. 组装数据
    OrderDTO dto = OrderDTO.from(order, products);
    
    // 5. 写入缓存
    cacheService.setOrder(id, dto);
    
    return dto;
}
```

### 2.2 架构升级

**案例**：单体应用拆分为微服务

**拆分策略**：
1. 按业务域拆分（用户、商品、订单）
2. 数据库独立
3. 服务间通过API/MQ通信

**挑战与解决**：
- **分布式事务**：使用Seata AT模式
- **数据一致性**：事件驱动 + 最终一致性
- **服务治理**：使用Nacos + Sentinel

## 三、业务架构

### 3.1 电商系统

```
┌─────────────┐
│  用户服务    │  注册、登录、用户信息
└──────┬──────┘
       │
┌──────▼──────┐
│  商品服务    │  商品管理、库存、分类
└──────┬──────┘
       │
┌──────▼──────┐
│  订单服务    │  下单、支付、订单查询
└──────┬──────┘
       │
┌──────▼──────┐
│  支付服务    │  支付、退款、对账
└─────────────┘
```

### 3.2 IM系统

```
┌──────────┐  WebSocket  ┌────────────┐
│  Client  │<─────────────│  Gateway   │
└──────────┘              └──────┬─────┘
                                 │
                          ┌──────▼─────┐
                          │ IM Service │
                          └──────┬─────┘
                 ┌────────────────┼────────────────┐
                 │                │                │
          ┌──────▼──────┐  ┌──────▼──────┐  ┌─────▼─────┐
          │    Redis    │  │    MySQL    │  │   Kafka   │
          │ (在线状态)   │  │ (消息存储)   │  │  (消息)   │
          └─────────────┘  └─────────────┘  └───────────┘
```

## 四、面试技巧

### 4.1 STAR法则

**Situation**（情境）：
- 项目背景、业务场景

**Task**（任务）：
- 你负责的具体任务

**Action**（行动）：
- 采取的技术方案
- 遇到的难点
- 如何解决

**Result**（结果）：
- 量化指标（性能提升、bug减少等）
- 业务价值

### 4.2 示例

**问**：介绍一个你负责的项目

**答**：

**S**: 我负责公司的电商平台，日均订单量10万+，大促期间峰值QPS达到5万。

**T**: 我主要负责订单服务的重构和性能优化。

**A**: 
1. **架构升级**：将单体应用拆分为微服务，使用Spring Cloud Alibaba
2. **性能优化**：
   - 引入Redis缓存，命中率95%+
   - SQL优化，添加联合索引
   - 使用MQ异步处理非核心流程
3. **高可用**：
   - 使用Sentinel限流降级
   - 订单服务多机房部署
   - 数据库主从读写分离

**R**:
- 接口响应时间从2s优化到200ms
- 系统可用性从99%提升到99.9%
- 支持大促期间5倍流量

---

**关键字**：项目经验、技术难点、STAR法则、业务架构、性能优化

