# 消息队列深度解析

## 目录
- [一、Kafka](#一kafka)
- [二、RocketMQ](#二rocketmq)
- [三、消息队列对比](#三消息队列对比)
- [四、高频面试题](#四高频面试题)

## 一、Kafka

### 1.1 核心概念

- **Producer**：生产者
- **Consumer**：消费者
- **Broker**：服务器节点
- **Topic**：主题
- **Partition**：分区
- **Offset**：偏移量

### 1.2 Producer

```java
@Component
public class KafkaProducerService {
    
    @Autowired
    private KafkaTemplate<String, String> kafkaTemplate;
    
    public void send(String topic, String message) {
        kafkaTemplate.send(topic, message).addCallback(
            result -> log.info("Success: {}", result),
            ex -> log.error("Failed", ex)
        );
    }
}
```

### 1.3 Consumer

```java
@Component
public class KafkaConsumerService {
    
    @KafkaListener(topics = "my-topic", groupId = "my-group")
    public void consume(String message) {
        log.info("Consumed: {}", message);
    }
}
```

### 1.4 核心特性

**1. 高吞吐**：
- 顺序写磁盘
- 页缓存
- 零拷贝

**2. 持久化**：
- 消息持久化到磁盘
- 多副本机制

**3. 分区**：
- 水平扩展
- 并行消费

## 二、RocketMQ

### 2.1 核心概念

- **NameServer**：路由中心
- **Broker**：存储消息
- **Producer**：生产者
- **Consumer**：消费者

### 2.2 消息类型

**1. 普通消息**：
```java
@Component
public class RocketMQProducer {
    
    @Autowired
    private RocketMQTemplate rocketMQTemplate;
    
    public void send(String topic, String message) {
        rocketMQTemplate.convertAndSend(topic, message);
    }
}
```

**2. 顺序消息**：
```java
public void sendOrderly(String topic, String message, String orderKey) {
    rocketMQTemplate.syncSendOrderly(topic, message, orderKey);
}
```

**3. 事务消息**：
```java
@Component
@RocketMQTransactionListener
public class TransactionListenerImpl implements RocketMQLocalTransactionListener {
    
    @Override
    public RocketMQLocalTransactionState executeLocalTransaction(Message msg, Object arg) {
        // 执行本地事务
        try {
            orderService.createOrder((Order) arg);
            return RocketMQLocalTransactionState.COMMIT;
        } catch (Exception e) {
            return RocketMQLocalTransactionState.ROLLBACK;
        }
    }
    
    @Override
    public RocketMQLocalTransactionState checkLocalTransaction(Message msg) {
        // 事务回查
        return RocketMQLocalTransactionState.COMMIT;
    }
}
```

## 三、消息队列对比

| 特性 | Kafka | RocketMQ | RabbitMQ |
|------|-------|----------|----------|
| 吞吐量 | 极高 | 高 | 中 |
| 延迟 | ms级 | ms级 | us级 |
| 可靠性 | 高 | 极高 | 高 |
| 消息有序 | 分区有序 | 支持全局有序 | 队列有序 |
| 事务消息 | 不支持 | 支持 | 支持 |

## 四、高频面试题

### Q1：Kafka如何保证消息不丢失？

1. **Producer**：设置acks=all
2. **Broker**：设置副本数>1
3. **Consumer**：手动提交offset

### Q2：Kafka如何保证消息顺序？

- 单分区内有序
- 使用相同key路由到同一分区

### Q3：RocketMQ事务消息原理？

1. 发送半消息（half message）
2. 执行本地事务
3. 提交或回滚
4. 事务回查

---

**关键字**：Kafka、RocketMQ、消息队列、事务消息、顺序消息

