# 推荐系统深度解析

## 目录
- [一、协同过滤](#一协同过滤)
- [二、深度学习推荐](#二深度学习推荐)
- [三、实时推荐架构](#三实时推荐架构)
- [四、高频面试题](#四高频面试题)

## 一、协同过滤

### 1.1 UserCF（基于用户）

```python
import numpy as np
from scipy.spatial.distance import cosine

class UserCF:
    def __init__(self, ratings_matrix):
        self.ratings_matrix = ratings_matrix
        self.similarity_matrix = self._calculate_similarity()
    
    def _calculate_similarity(self):
        n_users = self.ratings_matrix.shape[0]
        similarity = np.zeros((n_users, n_users))
        
        for i in range(n_users):
            for j in range(i+1, n_users):
                sim = 1 - cosine(
                    self.ratings_matrix[i],
                    self.ratings_matrix[j]
                )
                similarity[i, j] = similarity[j, i] = sim
        
        return similarity
    
    def recommend(self, user_id, k=10):
        # 找到最相似的用户
        similar_users = np.argsort(self.similarity_matrix[user_id])[::-1][1:k+1]
        
        # 推荐物品
        recommendations = {}
        for user in similar_users:
            for item_id, rating in enumerate(self.ratings_matrix[user]):
                if rating > 0 and self.ratings_matrix[user_id][item_id] == 0:
                    if item_id not in recommendations:
                        recommendations[item_id] = 0
                    recommendations[item_id] += rating * self.similarity_matrix[user_id][user]
        
        return sorted(recommendations.items(), key=lambda x: x[1], reverse=True)[:k]
```

### 1.2 ItemCF（基于物品）

```python
class ItemCF:
    def __init__(self, ratings_matrix):
        self.ratings_matrix = ratings_matrix.T  # 转置
        self.similarity_matrix = self._calculate_similarity()
    
    def recommend(self, user_id, k=10):
        user_ratings = self.ratings_matrix[:, user_id]
        scores = {}
        
        for item_id in range(len(user_ratings)):
            if user_ratings[item_id] > 0:
                continue
            
            score = 0
            for rated_item in np.where(user_ratings > 0)[0]:
                score += (self.similarity_matrix[item_id][rated_item] * 
                         user_ratings[rated_item])
            
            scores[item_id] = score
        
        return sorted(scores.items(), key=lambda x: x[1], reverse=True)[:k]
```

### 1.3 矩阵分解（MF）

```python
import numpy as np

class MatrixFactorization:
    def __init__(self, R, K, alpha=0.001, beta=0.02, iterations=100):
        self.R = R
        self.num_users, self.num_items = R.shape
        self.K = K
        self.alpha = alpha
        self.beta = beta
        self.iterations = iterations
    
    def train(self):
        # 初始化用户和物品矩阵
        self.P = np.random.normal(scale=1./self.K, size=(self.num_users, self.K))
        self.Q = np.random.normal(scale=1./self.K, size=(self.num_items, self.K))
        
        for iteration in range(self.iterations):
            for i in range(self.num_users):
                for j in range(self.num_items):
                    if self.R[i, j] > 0:
                        error = self.R[i, j] - np.dot(self.P[i, :], self.Q[j, :].T)
                        
                        # 更新参数
                        self.P[i, :] += self.alpha * (error * self.Q[j, :] - self.beta * self.P[i, :])
                        self.Q[j, :] += self.alpha * (error * self.P[i, :] - self.beta * self.Q[j, :])
            
            # 计算损失
            loss = 0
            for i in range(self.num_users):
                for j in range(self.num_items):
                    if self.R[i, j] > 0:
                        loss += pow(self.R[i, j] - np.dot(self.P[i, :], self.Q[j, :].T), 2)
                        loss += (self.beta/2) * (pow(np.linalg.norm(self.P[i, :]), 2) + 
                                                 pow(np.linalg.norm(self.Q[j, :]), 2))
            
            if (iteration+1) % 10 == 0:
                print(f"Iteration: {iteration+1}, Loss: {loss}")
        
        return self.P, self.Q
    
    def predict(self, user_id, item_id):
        return np.dot(self.P[user_id, :], self.Q[item_id, :].T)
```

## 二、深度学习推荐

### 2.1 DeepFM

```python
import tensorflow as tf

class DeepFM(tf.keras.Model):
    def __init__(self, feature_columns, hidden_units):
        super(DeepFM, self).__init__()
        
        # FM部分
        self.fm_first_order = tf.keras.layers.DenseFeatures(feature_columns)
        self.fm_second_order = tf.keras.layers.DenseFeatures(feature_columns)
        
        # Deep部分
        self.dnn_layers = [
            tf.keras.layers.Dense(units, activation='relu') 
            for units in hidden_units
        ]
        self.dnn_output = tf.keras.layers.Dense(1)
        
        # 输出层
        self.output_layer = tf.keras.layers.Dense(1, activation='sigmoid')
    
    def call(self, inputs):
        # FM一阶
        fm_first = self.fm_first_order(inputs)
        
        # FM二阶
        fm_second = self.fm_second_order(inputs)
        
        # Deep
        dnn = inputs
        for layer in self.dnn_layers:
            dnn = layer(dnn)
        dnn_output = self.dnn_output(dnn)
        
        # 组合
        output = self.output_layer(fm_first + fm_second + dnn_output)
        return output
```

### 2.2 Wide & Deep

```python
class WideAndDeep(tf.keras.Model):
    def __init__(self, wide_columns, deep_columns, deep_hidden_units):
        super(WideAndDeep, self).__init__()
        
        # Wide部分
        self.wide = tf.keras.layers.DenseFeatures(wide_columns)
        
        # Deep部分
        self.deep = tf.keras.layers.DenseFeatures(deep_columns)
        self.deep_layers = [
            tf.keras.layers.Dense(units, activation='relu')
            for units in deep_hidden_units
        ]
        
        # 输出层
        self.output_layer = tf.keras.layers.Dense(1, activation='sigmoid')
    
    def call(self, inputs):
        wide_output = self.wide(inputs)
        
        deep_output = self.deep(inputs)
        for layer in self.deep_layers:
            deep_output = layer(deep_output)
        
        combined = tf.concat([wide_output, deep_output], axis=1)
        return self.output_layer(combined)
```

## 三、实时推荐架构

### 3.1 整体架构

```
用户行为 → Kafka → Flink(实时特征) → Redis
                      ↓
                  特征服务
                      ↓
模型训练 ← 离线特征 ← Spark
   ↓
模型服务 → 推荐结果 → 用户
```

### 3.2 特征工程

```python
class FeatureEngineer:
    def __init__(self):
        self.redis_client = redis.Redis()
    
    def get_user_features(self, user_id):
        # 实时特征（Redis）
        recent_clicks = self.redis_client.zrevrange(
            f'user:{user_id}:clicks', 0, 99
        )
        
        # 离线特征（数据库）
        user_profile = self.db.query(
            f"SELECT age, gender, city FROM users WHERE id = {user_id}"
        )
        
        return {
            'user_id': user_id,
            'recent_clicks': recent_clicks,
            'age': user_profile.age,
            'gender': user_profile.gender,
            'city': user_profile.city
        }
    
    def get_item_features(self, item_id):
        return {
            'item_id': item_id,
            'category': self.get_category(item_id),
            'price': self.get_price(item_id),
            'popularity': self.get_popularity(item_id)
        }
```

### 3.3 在线服务

```python
from flask import Flask, request, jsonify

app = Flask(__name__)

@app.route('/recommend', methods=['POST'])
def recommend():
    user_id = request.json['user_id']
    k = request.json.get('k', 10)
    
    # 1. 召回
    recall_items = recall_service.recall(user_id, k * 10)
    
    # 2. 排序
    features = feature_engineer.get_features(user_id, recall_items)
    scores = model.predict(features)
    
    # 3. 重排序
    final_items = rerank(recall_items, scores)[:k]
    
    return jsonify({
        'user_id': user_id,
        'items': final_items
    })
```

## 四、高频面试题

### Q1：UserCF和ItemCF的区别？

| 特性 | UserCF | ItemCF |
|------|--------|--------|
| 适用场景 | 用户少 | 物品少 |
| 实时性 | 差 | 好 |
| 解释性 | 较弱 | 较强 |

### Q2：冷启动问题如何解决？

1. **用户冷启动**：
   - 热门推荐
   - 基于人口统计学
   - 引导用户填写兴趣

2. **物品冷启动**：
   - 基于内容推荐
   - 专家推荐
   - 探索策略（ε-greedy）

### Q3：推荐系统如何评估？

**离线评估**：
- RMSE、MAE
- Precision、Recall、F1
- NDCG、MAP

**在线评估**：
- CTR（点击率）
- CVR（转化率）
- 停留时间

---

**关键字**：协同过滤、DeepFM、Wide&Deep、推荐算法、特征工程

