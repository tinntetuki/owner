# 系统架构设计深度解析

## 目录
- [一、架构演进](#一架构演进)
- [二、微服务架构](#二微服务架构)
- [三、DDD领域驱动设计](#三ddd领域驱动设计)
- [四、CQRS与事件溯源](#四cqrs与事件溯源)
- [五、六边形架构](#五六边形架构)
- [六、架构模式对比](#六架构模式对比)
- [七、高频面试题](#七高频面试题)

## 一、架构演进

### 1.1 单体架构

```
┌─────────────────────────────┐
│     Web Layer               │
├─────────────────────────────┤
│     Service Layer           │
├─────────────────────────────┤
│     DAO Layer               │
├─────────────────────────────┤
│     Database                │
└─────────────────────────────┘
```

**优点**：
- 部署简单
- 开发效率高
- 易于测试

**缺点**：
- 扩展性差
- 技术栈单一
- 部署影响大

### 1.2 SOA架构

```
┌────────┐  ┌────────┐  ┌────────┐
│Service1│  │Service2│  │Service3│
└────┬───┘  └───┬────┘  └───┬────┘
     │          │            │
     └──────────┼────────────┘
                │
          ┌─────┴─────┐
          │   ESB     │
          └───────────┘
```

**特点**：
- 企业服务总线（ESB）
- 重量级框架
- 复杂的协议

### 1.3 微服务架构

```
┌─────────┐  ┌─────────┐  ┌─────────┐
│Service A│  │Service B│  │Service C│
│  + DB   │  │  + DB   │  │  + DB   │
└────┬────┘  └────┬────┘  └────┬────┘
     │            │             │
     └────────────┼─────────────┘
                  │
          ┌───────┴────────┐
          │  API Gateway   │
          └────────────────┘
```

**特点**：
- 服务独立部署
- 数据库独立
- 轻量级通信

## 二、微服务架构

### 2.1 微服务拆分原则

**拆分维度**：
1. **业务域拆分**：按业务能力
2. **DDD拆分**：按限界上下文
3. **数据拆分**：避免数据库耦合

**示例**：电商系统拆分
```
用户服务（User Service）
├── 用户注册登录
├── 用户信息管理
└── 用户权限

商品服务（Product Service）
├── 商品管理
├── 库存管理
└── 分类管理

订单服务（Order Service）
├── 下单
├── 订单查询
└── 订单状态管理

支付服务（Payment Service）
├── 支付
├── 退款
└── 对账
```

### 2.2 服务间通信

**同步通信**：
```java
// REST API
@FeignClient("product-service")
public interface ProductClient {
    @GetMapping("/products/{id}")
    Product getProduct(@PathVariable Long id);
}

// gRPC
@GrpcClient("product-service")
private ProductServiceGrpc.ProductServiceBlockingStub productStub;

public Product getProduct(Long id) {
    ProductRequest request = ProductRequest.newBuilder()
        .setId(id)
        .build();
    return productStub.getProduct(request);
}
```

**异步通信**：
```java
// 消息队列
@Component
public class OrderEventPublisher {
    
    @Autowired
    private RocketMQTemplate rocketMQTemplate;
    
    public void publishOrderCreated(Order order) {
        OrderCreatedEvent event = new OrderCreatedEvent(order);
        rocketMQTemplate.convertAndSend("order-topic", event);
    }
}

@Component
@RocketMQMessageListener(topic = "order-topic", consumerGroup = "inventory-group")
public class InventoryEventListener implements RocketMQListener<OrderCreatedEvent> {
    
    @Override
    public void onMessage(OrderCreatedEvent event) {
        // 扣减库存
        inventoryService.deduct(event.getProductId(), event.getQuantity());
    }
}
```

### 2.3 服务治理

**服务注册与发现**：
```yaml
# Nacos配置
spring:
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        namespace: prod
        group: DEFAULT_GROUP
```

**负载均衡**：
```java
@Configuration
public class LoadBalancerConfig {
    
    @Bean
    public IRule loadBalancerRule() {
        return new RandomRule();  // 随机
        // return new RoundRobinRule();  // 轮询
        // return new WeightedResponseTimeRule();  // 响应时间加权
    }
}
```

**限流熔断**：
```java
// Sentinel限流
@SentinelResource(
    value = "getProduct",
    blockHandler = "handleBlock",
    fallback = "handleFallback"
)
public Product getProduct(Long id) {
    return productService.getById(id);
}
```

## 三、DDD领域驱动设计

### 3.1 战略设计

**限界上下文**：
```
电商系统限界上下文：
┌──────────────┐  ┌──────────────┐
│  用户上下文   │  │  商品上下文   │
│  User Context│  │Product Context│
└──────┬───────┘  └───────┬──────┘
       │                  │
       │  ┌───────────────┴──┐
       └──┤  订单上下文       │
          │  Order Context   │
          └──────────────────┘
```

**上下文映射**：
- **共享内核**：共享领域模型
- **客户-供应商**：下游依赖上游
- **防腐层**：隔离外部系统
- **开放主机服务**：提供标准接口

### 3.2 战术设计

**聚合（Aggregate）**：
```java
// 订单聚合根
@Entity
public class Order {
    @Id
    private OrderId id;
    private UserId userId;
    private OrderStatus status;
    private Money totalAmount;
    
    @OneToMany(cascade = CascadeType.ALL)
    private List<OrderItem> items = new ArrayList<>();
    
    // 业务方法
    public void addItem(Product product, int quantity) {
        OrderItem item = new OrderItem(product, quantity);
        items.add(item);
        calculateTotalAmount();
    }
    
    public void submit() {
        if (items.isEmpty()) {
            throw new IllegalStateException("订单不能为空");
        }
        this.status = OrderStatus.SUBMITTED;
        // 发布领域事件
        DomainEventPublisher.publish(new OrderSubmittedEvent(this));
    }
    
    private void calculateTotalAmount() {
        this.totalAmount = items.stream()
            .map(OrderItem::getSubtotal)
            .reduce(Money.ZERO, Money::add);
    }
}

// 值对象
@Embeddable
public class Money {
    private BigDecimal amount;
    private String currency;
    
    public Money add(Money other) {
        if (!this.currency.equals(other.currency)) {
            throw new IllegalArgumentException("货币类型不匹配");
        }
        return new Money(this.amount.add(other.amount), this.currency);
    }
}
```

**领域服务**：
```java
@Service
public class OrderDomainService {
    
    public void transferOrder(Order order, User newOwner) {
        // 跨聚合的业务逻辑
        order.transferTo(newOwner);
        userRepository.save(newOwner);
        orderRepository.save(order);
    }
}
```

**工厂（Factory）**：
```java
public class OrderFactory {
    
    public static Order createOrder(User user, List<CartItem> cartItems) {
        Order order = new Order(user.getId());
        for (CartItem cartItem : cartItems) {
            order.addItem(cartItem.getProduct(), cartItem.getQuantity());
        }
        return order;
    }
}
```

**仓储（Repository）**：
```java
public interface OrderRepository {
    Order findById(OrderId id);
    void save(Order order);
    List<Order> findByUserId(UserId userId);
}

@Repository
public class OrderRepositoryImpl implements OrderRepository {
    
    @PersistenceContext
    private EntityManager entityManager;
    
    @Override
    public Order findById(OrderId id) {
        return entityManager.find(Order.class, id);
    }
    
    @Override
    public void save(Order order) {
        if (order.getId() == null) {
            entityManager.persist(order);
        } else {
            entityManager.merge(order);
        }
    }
}
```

### 3.3 分层架构

```
┌─────────────────────────────┐
│  User Interface Layer       │  ← Controller, DTO
├─────────────────────────────┤
│  Application Layer          │  ← Application Service
├─────────────────────────────┤
│  Domain Layer               │  ← Entity, Value Object, Domain Service
├─────────────────────────────┤
│  Infrastructure Layer       │  ← Repository Impl, External Service
└─────────────────────────────┘
```

**应用服务**：
```java
@Service
@Transactional
public class OrderApplicationService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    @Autowired
    private OrderFactory orderFactory;
    
    public OrderDTO createOrder(CreateOrderCommand command) {
        // 1. 加载领域对象
        User user = userRepository.findById(command.getUserId());
        List<CartItem> cartItems = cartRepository.findByUserId(user.getId());
        
        // 2. 执行领域逻辑
        Order order = orderFactory.createOrder(user, cartItems);
        order.submit();
        
        // 3. 持久化
        orderRepository.save(order);
        
        // 4. 返回DTO
        return OrderDTO.from(order);
    }
}
```

## 四、CQRS与事件溯源

### 4.1 CQRS（命令查询职责分离）

```
┌───────────┐     ┌────────────┐
│  Command  │────▶│ Write DB   │
│  Handler  │     └────────────┘
└───────────┘            │
                         │ Event
                         ▼
                  ┌────────────┐
                  │Event Handler│
                  └──────┬─────┘
                         │
                         ▼
┌───────────┐     ┌────────────┐
│   Query   │◀────│  Read DB   │
│  Handler  │     └────────────┘
└───────────┘
```

**命令模型**：
```java
// 命令
public class CreateOrderCommand {
    private Long userId;
    private List<OrderItemDTO> items;
}

// 命令处理器
@Component
public class CreateOrderCommandHandler {
    
    public OrderId handle(CreateOrderCommand command) {
        Order order = new Order(command.getUserId());
        command.getItems().forEach(item -> 
            order.addItem(item.getProductId(), item.getQuantity())
        );
        orderRepository.save(order);
        
        // 发布事件
        eventBus.publish(new OrderCreatedEvent(order.getId()));
        
        return order.getId();
    }
}
```

**查询模型**：
```java
// 查询
public class GetOrderQuery {
    private Long orderId;
}

// 查询处理器
@Component
public class GetOrderQueryHandler {
    
    @Autowired
    private OrderQueryRepository queryRepository;
    
    public OrderDetailDTO handle(GetOrderQuery query) {
        return queryRepository.findOrderDetail(query.getOrderId());
    }
}

// 查询仓储（可以是不同的数据库，如ES、MongoDB）
@Repository
public class OrderQueryRepository {
    
    public OrderDetailDTO findOrderDetail(Long orderId) {
        // 从Read DB查询
        return jdbcTemplate.queryForObject(
            "SELECT * FROM order_detail_view WHERE id = ?",
            new OrderDetailRowMapper(),
            orderId
        );
    }
}
```

### 4.2 事件溯源（Event Sourcing）

**事件存储**：
```java
@Entity
public class DomainEvent {
    @Id
    private String eventId;
    private String aggregateId;
    private String eventType;
    private String eventData;
    private LocalDateTime occurredOn;
    private int version;
}

@Component
public class EventStore {
    
    public void append(String aggregateId, DomainEvent event) {
        event.setVersion(getNextVersion(aggregateId));
        eventRepository.save(event);
    }
    
    public List<DomainEvent> getEvents(String aggregateId) {
        return eventRepository.findByAggregateIdOrderByVersion(aggregateId);
    }
}
```

**事件溯源聚合**：
```java
public class OrderEventSourced {
    private OrderId id;
    private List<DomainEvent> uncommittedEvents = new ArrayList<>();
    
    // 从事件重建状态
    public static OrderEventSourced fromEvents(List<DomainEvent> events) {
        OrderEventSourced order = new OrderEventSourced();
        events.forEach(order::apply);
        return order;
    }
    
    // 创建订单
    public void create(UserId userId) {
        OrderCreatedEvent event = new OrderCreatedEvent(OrderId.generate(), userId);
        apply(event);
        uncommittedEvents.add(event);
    }
    
    // 应用事件
    private void apply(DomainEvent event) {
        if (event instanceof OrderCreatedEvent) {
            OrderCreatedEvent e = (OrderCreatedEvent) event;
            this.id = e.getOrderId();
        } else if (event instanceof OrderItemAddedEvent) {
            // 更新状态
        }
    }
}
```

## 五、六边形架构

### 5.1 架构结构

```
             ┌────────────────────┐
             │   Driving Adapter  │
             │  (Web, CLI, Test)  │
             └─────────┬──────────┘
                       │
             ┌─────────▼──────────┐
             │   Application      │
             │   (Use Cases)      │
             └─────────┬──────────┘
                       │
             ┌─────────▼──────────┐
             │   Domain Model     │
             │  (Business Logic)  │
             └─────────┬──────────┘
                       │
             ┌─────────▼──────────┐
             │  Driven Adapter    │
             │ (DB, MQ, External) │
             └────────────────────┘
```

### 5.2 实现示例

**领域层（核心）**：
```java
// 端口（接口）
public interface OrderRepository {
    void save(Order order);
    Order findById(OrderId id);
}

public interface PaymentService {
    PaymentResult pay(Order order);
}

// 领域模型
public class Order {
    private OrderId id;
    private OrderStatus status;
    
    public void pay(PaymentService paymentService) {
        PaymentResult result = paymentService.pay(this);
        if (result.isSuccess()) {
            this.status = OrderStatus.PAID;
        }
    }
}
```

**应用层**：
```java
@Service
public class OrderApplicationService {
    private final OrderRepository orderRepository;
    private final PaymentService paymentService;
    
    public void payOrder(OrderId orderId) {
        Order order = orderRepository.findById(orderId);
        order.pay(paymentService);
        orderRepository.save(order);
    }
}
```

**适配器层**：
```java
// Driving Adapter - REST
@RestController
public class OrderController {
    @Autowired
    private OrderApplicationService orderService;
    
    @PostMapping("/orders/{id}/pay")
    public void payOrder(@PathVariable Long id) {
        orderService.payOrder(new OrderId(id));
    }
}

// Driven Adapter - Repository
@Repository
public class JpaOrderRepository implements OrderRepository {
    @PersistenceContext
    private EntityManager em;
    
    @Override
    public void save(Order order) {
        em.merge(order);
    }
}

// Driven Adapter - External Service
@Component
public class WechatPaymentService implements PaymentService {
    @Override
    public PaymentResult pay(Order order) {
        // 调用微信支付API
        return wechatClient.pay(order);
    }
}
```

## 六、架构模式对比

| 架构 | 复杂度 | 可维护性 | 可测试性 | 适用场景 |
|------|-------|---------|---------|---------|
| 单体 | 低 | 中 | 中 | 小型项目 |
| 分层 | 低 | 中 | 中 | 中小型项目 |
| 微服务 | 高 | 高 | 高 | 大型分布式系统 |
| DDD | 高 | 高 | 高 | 复杂业务领域 |
| CQRS | 高 | 高 | 高 | 读写分离场景 |
| 六边形 | 中 | 高 | 高 | 需要高度解耦 |

## 七、高频面试题

### Q1：什么时候应该使用微服务？

**适用场景**：
- 团队规模大（>20人）
- 业务复杂度高
- 需要独立扩展
- 不同模块技术栈差异大

**不适用场景**：
- 小团队（<5人）
- 业务简单
- 初创项目

### Q2：微服务的优缺点？

**优点**：
- 独立部署和扩展
- 技术栈灵活
- 故障隔离
- 团队自治

**缺点**：
- 分布式复杂性
- 运维成本高
- 数据一致性
- 调试困难

### Q3：DDD中的聚合是什么？

聚合是一组相关对象的集合，作为一个整体来处理数据变更。

**特点**：
- 有聚合根
- 保证一致性边界
- 对外只暴露聚合根

### Q4：CQRS适用场景？

**适用**：
- 读写比例差异大
- 读写逻辑复杂度不同
- 需要不同的数据模型

**不适用**：
- 简单CRUD
- 一致性要求极高

---

**关键字**：微服务、DDD、CQRS、事件溯源、六边形架构、限界上下文、聚合

